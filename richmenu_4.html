<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>æ”¯æ’ç›¸é—œ</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body, html {
      font-size: 18px;
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: Arial, sans-serif;
    }

    .container {
      display: flex;
      height: 100%;
    }

    .sidebar {
      width: 240px;
      background-color: #2c3e50;
      color: white;
      padding: 60px 20px 20px;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    .sidebar h2 {
      font-size: 20px;
      margin-bottom: 16px;
    }

    .sidebar ul {
      list-style: none;
      padding: 0;
    }

    .sidebar ul li {
      margin: 12px 0;
      cursor: pointer;
      color: #ecf0f1;
    }

    .sidebar ul li:hover {
      color: #1abc9c;
    }

    .main-content {
      flex-grow: 1;
      padding: 20px;
      padding-top: 60px; /* âœ… å¤§è¢å¹•ç‰ˆ */
      overflow-y: auto;
    }

    .menu-button {
      display: none;
      position: fixed;
      top: 10px;
      left: 10px;
      background-color: #2c3e50;
      color: white;
      border: none;
      padding: 10px 14px;
      font-size: 16px;
      cursor: pointer;
      z-index: 1000;
    }
    .form-group {
      margin-bottom: 12px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 4px;
      color: #333;
    }
    
    .form-group input {
      width: 100%;
      padding: 8px;
      font-size: 16px;
    }

    @media (max-width: 768px) {
      .main-content {
        padding-top: 30px; /* æ‰‹æ©Ÿé›¢é ‚éƒ¨æœ‰é»è·é›¢ */
      }
      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100%;
        z-index: 999;
        transform: translateX(-100%);
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .menu-button {
        display: block;
      }

      .container {
        flex-direction: column;
      }
    }

    select, input {
      margin: 2px 0;
      padding: 2px 4px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: border-color 0.2s, box-shadow 0.2s;
      outline: none;
    }

    select:focus, input:focus {
      border-color: #4a90e2;
      box-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
    }

    button {
      margin: 10px 0;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50; /* ç¶ è‰² */
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, box-shadow 0.3s;
    }

    button:hover {
      background-color: #45a049;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    button:active {
      background-color: #3e8e41;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .result {
      margin-top: 20px;
      padding: 15px;
      background-color: #ecf0f1;
      border-left: 4px solid #1abc9c;
    }
    .result-section {
      margin-bottom: 16px;
    }

    .result-section h3 {
      border-bottom: 2px solid #1abc9c;
      padding-bottom: 4px;
      margin-bottom: 10px;
      color: #16a085;
    }

    .result-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px dashed #ccc;
    }

    .result-label {
      flex: 1;
      color: #333;
    }

    .result-value {
      flex: 0 0 auto;
      font-weight: bold;
      color: #e67e22;
    }

  </style>

</head>
<body>

  <button class="menu-button" onclick="toggleSidebar()">é¸å–®</button>

  <div class="container">
    <div class="sidebar" id="sidebar">
      <h2>æ•¸å­¸ä¸å¥½</h2>
      <ul>
        <li onclick="showCalculationForm()">è¨ˆç®—</li>
      </ul>
    </div>
    <div class="main-content" id="main-content">
      <h2>å¥—ä¸€å¥èŠ±æœæœäºŒçš„åè¨€:<br>
        <span style="color: red;">æˆä¹Ÿæ”¯æ’æ•—ä¹Ÿæ”¯æ’</span>
      <p><strong>èªªæ˜ï¼š</strong></p>
      <ul style="padding-left: 30px; line-height: 1.6;">
        <li>æ”¯æ’ç¨®é¡åŒ…å«ï¼š<br>ç®±å‹æ”¯æ’ã€ç‰†é¢æ”¯æ’ã€æ–œæ¨“æ¿æ”¯æ’</li>
        <li>å¯æ ¹æ“šç¾å ´æ¸¬é‡è³‡æ–™è‡ªå‹•è¨ˆç®—æ‰€éœ€æ”¯æ’é•·åº¦èˆ‡ææ–™</li>
        <li>è¨ˆç®—çµæœæœƒå€åˆ†ç‚º<br>ã€Œè‡¨æ™‚æ”¯æ’ã€<br>ã€Œå®Œæ•´æ”¯æ’ã€</li>
      </ul>
      <ul style="padding-left: 28px; line-height: 1.6; background-color: #ffe5e5;">
        <li style="color: red; font-weight: bold;">å°æœ‹å‹æ‰è¨ˆè¼ƒå¾—å¾ˆç²¾ç´°</li>
      </ul>

      <p style="color: #666; font-size: 14px;">è«‹é»é¸å·¦å´é¸å–®ä¾†é–‹å§‹é¸æ“‡è¨ˆç®—é¡å‹ã€‚</p>
    </div>


    <!-- ...existing code... -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.124.0/examples/js/controls/OrbitControls.min.js"></script>

  <!-- ...existing code... -->
  </div>

  <script>
    function toggleSidebar() {
      document.getElementById("sidebar").classList.toggle("open");
    }

    function showCalculationForm() {
      const container = document.getElementById("main-content");
      container.innerHTML = `
        <h2>æ”¯æ’è¨ˆç®—</h2>
        <label>é¸æ“‡è¨ˆç®—é¡å‹ï¼š
          <select id="calcType" onchange="renderCalcForm()">
            <option value="">ğŸ‘‰ğŸ‘‰é»æˆ‘é¸æ“‡æ”¯æ’é¡å‹ğŸ’¡ğŸ’¡</option>
            <option value="box">ğŸ“¦ğŸ“¦ç®±å‹æ”¯æ’ğŸ“¦ğŸ“¦</option>
            <option value="wall">ğŸ§±ğŸ§±ç‰†é¢æ”¯æ’ğŸ§±ğŸ§±</option>
            <option value="floor">ğŸ“ğŸ“æ–œæ¨“æ¿æ”¯æ’ğŸ“ğŸ“</option>
          </select>
        </label>
        <div id="dynamicForm"></div>
        <div id="dynamicResult"></div>
      `;

      if (window.innerWidth <= 768) {
        document.getElementById("sidebar").classList.remove("open");
      }
    }

    function renderCalcForm() {
      const type = document.getElementById("calcType").value;
      const form = document.getElementById("dynamicForm");
      const result = document.getElementById("dynamicResult");
      result.innerHTML = "";

      if (type === "box") {
        form.innerHTML = `
          <div class="form-group">
            <label for="length">æ¸¬é‡é•·åº¦ (cm)ï¼š</label>
            <input type="number" id="length" />
          </div>
          <button onclick="calculateBox()">ğŸ§ è¨ˆç®—ç®±å‹æ”¯æ’ğŸ“</button>
          <div class="form-group">
            <label for="top">é ‚æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="top" value="10" />
          </div>
          <div class="form-group">
            <label for="bottom">åº•æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="bottom" value="10" />
          </div>
          <div class="form-group">
            <label for="wedge">æ¥”å‹æœ¨åšåº¦ (cm)ï¼š</label>
            <input type="number" id="wedge" value="5" />
          </div>
          <div class="form-group">
            <label for="spacing">æ”¯æ’æŸ±é–“è· (cm)ï¼š</label>
            <input type="number" id="spacing" value="120" />
          </div>
          <div class="form-group">
            <label for="connector">é€£æ¥æŸ±å¯¬åº¦ (cm)ï¼š</label>
            <input type="number" id="connector" value="10" />
          </div>
        `;
      } else if (type === "wall") {
        form.innerHTML = `
          <div class="form-group">
            <label for="length">æ¸¬é‡é•·åº¦ (cm)ï¼š</label>
            <input type="number" id="length" />
          </div>
          <button onclick="calculateWall()">ğŸ§ è¨ˆç®—ç‰†é¢æ”¯æ’ğŸ“</button>
          <div class="form-group">
            <label for="top">é ‚æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="top" value="10" />
          </div>
          <div class="form-group">
            <label for="bottom">åº•æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="bottom" value="10" />
          </div>
          <div class="form-group">
            <label for="wedge">æ¥”å‹æœ¨åšåº¦ (cm)ï¼š</label>
            <input type="number" id="wedge" value="10" />
          </div>
          <div class="form-group">
            <label for="spacing">æ”¯æ’æŸ±é–“è· (cm)ï¼š</label>
            <input type="number" id="spacing" value="120" />
          </div>
          <div class="form-group">
            <label for="connector">é€£æ¥æŸ±å¯¬åº¦ (cm)ï¼š</label>
            <input type="number" id="connector" value="15" />
          </div>
          <div class="form-group">
            <label for="stopper">æ­¢æª”å¯¬åº¦ (cm)ï¼š</label>
            <input type="number" id="stopper" value="5" />
          </div>
          <div class="form-group">
            <label for="angle">è§’åº¦ (é€™è£¡åªè¨ˆç®—45åº¦)ï¼š</label>
            <input type="number" id="angle" value="45" readonly />
          </div>
        `;
      } else if (type === "floor") {
        form.innerHTML = `
          <div class="form-group">
            <label for="length">æ¸¬é‡é•·åº¦ (cm)ï¼š</label>
            <input type="number" id="length" />
          </div>
          <button onclick="calculateFloor()">ğŸ§ è¨ˆç®—æ¨“æ¿æ”¯æ’ğŸ“</button>
          <div class="form-group">
            <label for="top">é ‚æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="top" value="10" />
          </div>
          <div class="form-group">
            <label for="bottom">åº•æ¿åšåº¦ (cm)ï¼š</label>
            <input type="number" id="bottom" value="10" />
          </div>
          <div class="form-group">
            <label for="spacing">æ”¯æ’æŸ±é–“è· (cm)ï¼š</label>
            <input type="number" id="spacing" value="120" />
          </div>
          <div class="form-group">
            <label for="connector">é€£æ¥æŸ±å¯¬åº¦ (cm)ï¼š</label>
            <input type="number" id="connector" value="15" />
          </div>
          <div class="form-group">
            <label for="stopper">æ­¢æª”å¯¬åº¦ (cm)ï¼š</label>
            <input type="number" id="stopper" value="5" />
          </div>
          <div class="form-group">
            <label for="angle">è§’åº¦ (æœ€å¤š45åº¦)ï¼š</label>
            <input type="number" id="angle" value="45" max="45"/>
          </div>
        `;
        

      } else {
        form.innerHTML = "";
      }
    }

    function calculateWall() {
      const parsedData = {
        "æ¸¬é‡é•·åº¦": parseFloat(document.getElementById("length").value),
        "é ‚æ¿åšåº¦": parseFloat(document.getElementById("top").value),
        "åº•æ¿åšåº¦": parseFloat(document.getElementById("bottom").value),
        "æ¥”å‹æœ¨åšåº¦": parseFloat(document.getElementById("wedge").value),
        "æ”¯æ’æŸ±é–“è·": parseFloat(document.getElementById("spacing").value),
        "é€£æ¥æŸ±å¯¬åº¦": parseFloat(document.getElementById("connector").value),
        "æ­¢æª”å¯¬åº¦": parseFloat(document.getElementById("stopper").value),
        "è§’åº¦": parseFloat(document.getElementById("angle").value),
      };

      const result = document.getElementById("dynamicResult");

      if (Object.values(parsedData).every(val => !isNaN(val))) {
        const rad = parsedData["è§’åº¦"] * Math.PI / 180;
        const rad90 = (90 - parsedData["è§’åº¦"]) * Math.PI / 180;
        const shorelength = ((parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 -parsedData["é ‚æ¿åšåº¦"]) * Math.cos(rad)+parsedData["æ¥”å‹æœ¨åšåº¦"] * Math.tan(rad)* Math.sin(rad)+parsedData["æ¥”å‹æœ¨åšåº¦"] / Math.tan(rad)* Math.cos(rad)).toFixed(1);
        const headerlength = (parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 + 60 + 15 ).toFixed(1);
        const bottomlength = ((parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 - parsedData["é ‚æ¿åšåº¦"]) + parsedData["æ¥”å‹æœ¨åšåº¦"]  + 60 + 15).toFixed(1);
        const temporaryShore = ((parsedData["æ¸¬é‡é•·åº¦"] - 75) * Math.SQRT2 - 5).toFixed(1);
        const toplength = parsedData["æ¸¬é‡é•·åº¦"] < 180? parsedData["æ¸¬é‡é•·åº¦"] - 10: 180;
        let warningMessage = "";
        if (parsedData["æ¸¬é‡é•·åº¦"] < headerlength) {
          warningMessage = `<div class="warning" style="color:red; font-weight:bold; padding: 10px 0;">
            âš ï¸âš ï¸âš ï¸ è¨ˆç®—çš„é ‚æ¿å€¼ > å¯¦éš›æ¸¬é‡é«˜åº¦ âš ï¸âš ï¸âš ï¸
          </div>`;
        }
        
        result.innerHTML = `
          <div class="result">
            ${warningMessage}
            <div class="result-section">

              <h3>è‡¨æ™‚æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚æ¿</div><div class="result-value">${toplength} * 2</div></div>
              <div class="result-row"><div class="result-label">æ”¯æ’æŸ±</div><div class="result-value">${temporaryShore} * 2</div></div>
              <div class="result-row"><div class="result-label">æ§½å¼åŸºåº§</div><div class="result-value">2å€‹</div></div>
              <div class="result-row"><div class="result-label">é€£æ¥æŸ±</div><div class="result-value">120 * 4</div></div>
              <div class="result-row"><div class="result-label">æ­¢æª”</div><div class="result-value">60 * 2</div></div>
              <div class="result-row"><div class="result-label">å…¨å¤¾æ¿</div><div class="result-value">4ç‰‡</div></div>
              <div class="result-row"><div class="result-label">å¤§æ¥”å½¢æœ¨</div><div class="result-value">2çµ„</div></div>
              <div class="result-row"><div class="result-label">é‹¼ç­‹</div><div class="result-value">ç´„10æ ¹</div></div>
              <div class="result-row"><div class="result-label">åŸºåº§é˜²æ»‘æœ¨</div><div class="result-value">2å€‹ç´„30~45å…¬åˆ†</div></div>
            </div>
            <div class="result-section">
              <h3>å®Œæ•´æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚æ¿</div><div class="result-value">${headerlength} * 2</div></div>
              <div class="result-row"><div class="result-label">åº•æ¿</div><div class="result-value">${bottomlength} * 2</div></div>
              <div class="result-row"><div class="result-label">æ”¯æ’æŸ±</div><div class="result-value">${shorelength} * 2</div></div>
              <div class="result-row"><div class="result-label">ä¸­é»é€£æ¥</div><div class="result-value">ç´„ ${(shorelength / 2).toFixed(1)} * 4</div></div>
              <div class="result-row"><div class="result-label">æ­¢æª”</div><div class="result-value">60 * 4</div></div>
              <div class="result-row"><div class="result-label">å…¨å¤¾æ¿</div><div class="result-value">12ç‰‡</div></div>
              <div class="result-row"><div class="result-label">å¤§æ¥”å½¢æœ¨</div><div class="result-value">4çµ„</div></div>
              <div class="result-row"><div class="result-label">é‹¼ç­‹</div><div class="result-value">8~12æ ¹</div></div>
              <div class="result-row"><div class="result-label">é•·æ•æœ¨</div><div class="result-value">1æ”¯</div></div>
            </div>
          </div>
        <!-- ...existing code... -->
        <div id="threejs-box-viewer" style="width:100%;height:350px;"></div>
        <!-- ...existing code... -->
        `;
        // æ¸…é™¤èˆŠçš„ 3D ç•«å¸ƒ
        const oldCanvas = document.getElementById("threejs-canvas");
        if (oldCanvas) oldCanvas.remove();

        // å»ºç«‹ Three.js å ´æ™¯
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, 400/350, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(400, 350);
        renderer.domElement.id = "threejs-canvas";
        document.getElementById("threejs-box-viewer").appendChild(renderer.domElement);

        // åŠ å…¥å…‰æº
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 2, 3);
        scene.add(light);
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        // ä»¥ä¸Šç‚ºç’°å¢ƒè¨­ç½®
        const angle = parsedData["è§’åº¦"] * Math.PI / 180;
        const height = parsedData["æ¸¬é‡é•·åº¦"] / 100 / 2; // m
        const spacing = parsedData["æ”¯æ’æŸ±é–“è·"] / 100; // m
        const connectorThickness = parsedData["é€£æ¥æŸ±å¯¬åº¦"] / 100; // é€£æ¥æŸ±å¯¬åº¦ï¼Œå–®ä½ m
        const wedgeThickness = parsedData["æ¥”å‹æœ¨åšåº¦"] / 100; // æ¥”å‹æœ¨åšåº¦ï¼Œå–®ä½ m
        const thickness = 0.1; // é è¨­å›ºå®š10Cm
        const idealLength = parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 / 100; // 2/3hï¼Œå–®ä½ m
        const stopperWidth = parsedData["æ­¢æª”å¯¬åº¦"] / 100; // æ­¢æª”å¯¬åº¦ï¼Œå–®ä½ m
        const topLength = parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 / 100 + 0.6+ 0.15; // é ‚æ¿é•·åº¦ï¼Œå–®ä½ m
        const topThickness = parsedData["é ‚æ¿åšåº¦"] / 100; // é ‚æ¿åšåº¦ï¼Œå–®ä½ m
        const bottomThickness = parsedData["åº•æ¿åšåº¦"] / 100; // åº•æ¿åšåº¦ï¼Œå–®ä½ m
        const bottomLength = parsedData["æ¸¬é‡é•·åº¦"] * 2 / 3 / 100 -topThickness + parsedData["æ¥”å‹æœ¨åšåº¦"]/100 + 0.6 + 0.15 ; // åº•æ¿é•·åº¦ï¼Œå–®ä½ m
        const shoreLength = Math.sqrt(Math.pow(idealLength - bottomThickness +  stopperWidth * Math.tan(angle) ,2) + Math.pow(idealLength - topThickness + stopperWidth / Math.tan(angle),2)); // æ”¯æ’æŸ±é•·åº¦ï¼Œå–®ä½ m

        // å…ˆå»ºç«‹åº•æ¿
        const bottomGeometry = new THREE.BoxGeometry(bottomLength, bottomThickness, thickness);
        const bottomMaterial = new THREE.MeshPhongMaterial({
          color: 0xf1c40f, // é»ƒè‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });

        // åŸé»
        const offsetX =  bottomLength /2; // æ”¾åœ¨x0
        const offsetY = parsedData["æ¸¬é‡é•·åº¦"] / 100 * 2 / 3;
        const offsetZ = spacing / 2 - (thickness / 2); // Zè»¸åç§»
        const bottomPositions = [
            [ offsetX + topThickness, bottomThickness / 2, offsetZ], // åº•æ¿ä½ç½®
            [ offsetX + topThickness, bottomThickness / 2, -offsetZ], // åº•æ¿ä½ç½®
        ];

        // å»ºç«‹åº•æ¿
        bottomPositions.forEach(pos => {
          const bottomBoard = new THREE.Mesh(bottomGeometry, bottomMaterial.clone());
          bottomBoard.position.set(...pos);
          scene.add(bottomBoard);
        });
        
        // å»ºç«‹æ”¯æ’æŸ± geometry
        const pillarGeometry = new THREE.BoxGeometry(topThickness, topLength, thickness);
        const pillarMaterial = new THREE.MeshPhongMaterial({
          color: 0x1abc9c, // ç¶ è‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });
        const bottomX = thickness/2;
        const bottomY = topLength / 2 + bottomThickness ; // åº•éƒ¨Yè»¸ä½ç½®
        // æŸ±å­åº§æ¨™ï¼ˆäºŒæ ¹ï¼‰
        const pillarPositions = [
          [bottomX  ,bottomY- bottomThickness, offsetZ], // ç¬¬ä¸€æ ¹æŸ±å­
          [bottomX , bottomY- bottomThickness, -offsetZ] // ç¬¬äºŒæ ¹æŸ±å­
        ];
        // å»ºç«‹å…©æ ¹æ”¯æ’æŸ±
        pillarPositions.forEach(pos => {
          const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial.clone());
          pillar.position.set(...pos); 
          scene.add(pillar);
        });
        // å»ºç«‹æ”¯æ’æŸ±
        const shoreGeometry = new THREE.BoxGeometry(thickness, shoreLength, thickness-0.0001);
        const shoreMaterial = new THREE.MeshPhongMaterial({
          color: 0x3498db, // è—è‰²
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        // è¨ˆç®—åè½‰è§’åº¦
        const shoreStart = new THREE.Vector3(bottomThickness, idealLength + stopperWidth * Math.tan(angle), offsetZ);
        const shoreEnd = new THREE.Vector3(idealLength + stopperWidth / Math.tan(angle), bottomThickness, offsetZ);
        const shoreDirection = new THREE.Vector3().subVectors(shoreStart, shoreEnd).normalize();
        const shoremid = new THREE.Vector3().addVectors(shoreStart,shoreEnd).multiplyScalar(0.5);
        const shoreAxis = new THREE.Vector3(0, 1, 0); // Zè»¸æ–¹å‘
        const shoreQuaternion = new THREE.Quaternion().setFromUnitVectors(shoreAxis, shoreDirection);
        // æ”¯æ’æŸ±ä½ç½®
        const shorePositionsX = (bottomThickness + idealLength + stopperWidth / Math.tan(angle))/2; // Xè»¸ä½ç½®
        const shorePositionsY = (bottomThickness + idealLength + stopperWidth * Math.tan(angle))/2; // Yè»¸ä½ç½®
        const shorePositions = [
          [shorePositionsX- thickness/2 * Math.sin(angle), shorePositionsY- thickness/2 * Math.cos(angle), offsetZ], // ç¬¬ä¸€æ ¹æ”¯æ’æŸ±
          [shorePositionsX- thickness/2 * Math.sin(angle), shorePositionsY- thickness/2 * Math.cos(angle), -offsetZ] // ç¬¬äºŒæ ¹æ”¯æ’æŸ±
        ];
        
        // å»ºç«‹æ”¯æ’æŸ±
        shorePositions.forEach(pos => {
          const shore = new THREE.Mesh(shoreGeometry, shoreMaterial.clone());
          shore.position.set(...pos);
          shore.quaternion.copy(shoreQuaternion); // è¨­ç½®æ—‹è½‰
          scene.add(shore);
        });

        // å»ºç«‹æ­¢é»¨
        const stopperGeometry = new THREE.BoxGeometry(0.6, stopperWidth, thickness);
        const stopperMaterial = new THREE.MeshPhongMaterial({
          color: 0xe67e22, // æ©™è‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });
        // æ­¢é»¨ä½ç½®
        const stopperX = shoreEnd.x + stopperGeometry.parameters.width /2  - stopperWidth / Math.tan(angle) + wedgeThickness; // æ­¢é»¨Xè»¸ä½ç½®
        const stopperY = bottomThickness + stopperGeometry.parameters.height / 2; // æ­¢é»¨Yè»¸ä½ç½®
        const stopperPositions = [
          [stopperX, stopperY, offsetZ], // æ­£é¢ä¸‹æ–¹
          [stopperX, stopperY, -offsetZ], // èƒŒé¢ä¸‹æ–¹
        ];
        // å»ºç«‹æ­¢é»¨
        stopperPositions.forEach(pos => {
          const stopper = new THREE.Mesh(stopperGeometry, stopperMaterial.clone());
          stopper.position.set(...pos);
          scene.add(stopper);
        });

        const stopperGeometry_2 = new THREE.BoxGeometry(stopperWidth, 0.6, thickness);
        const stopperMaterial_2 = new THREE.MeshPhongMaterial({
          color: 0xe67e22, // æ©™è‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });
        // æ­¢é»¨ä½ç½®
        const stopperX_2 = shoreStart.x + stopperGeometry_2.parameters.width /2  ; // æ­¢é»¨Xè»¸ä½ç½®
        const stopperY_2 = shoreStart.y + stopperGeometry_2.parameters.height / 2 - stopperWidth * Math.tan(angle); // æ­¢é»¨Yè»¸ä½ç½®
        const stopperPositions_2 = [
          [stopperX_2, stopperY_2, offsetZ], // æ­£é¢ä¸‹æ–¹
          [stopperX_2, stopperY_2, -offsetZ], // èƒŒé¢ä¸‹æ–¹
        ];
        // å»ºç«‹æ­¢é»¨
        stopperPositions_2.forEach(pos => {
          const stopper = new THREE.Mesh(stopperGeometry_2, stopperMaterial_2.clone());
          stopper.position.set(...pos);
          scene.add(stopper);
        });

        // å»ºç«‹wedge
        const wedgeGeometry = new THREE.BoxGeometry(wedgeThickness, thickness, 0.45);
        const wedgeMaterial = new THREE.MeshPhongMaterial({
          color: 0x9b59b6, // ç´«è‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });
        // æ¥”å‹æœ¨ä½ç½®
        const wedgeX = stopperX - wedgeThickness/2 - stopperGeometry.parameters.width/2; // æ¥”å‹æœ¨Xè»¸ä½ç½®
        const wedgeY = bottomThickness + wedgeThickness/2; // æ¥”å‹æœ¨Yè»¸ä½ç½®
        const wedgePositions = [
          [wedgeX, wedgeY, offsetZ], // æ­£é¢ä¸‹æ–¹
          [wedgeX, wedgeY, -offsetZ], // èƒŒé¢ä¸‹æ–¹
        ];
        // å»ºç«‹æ¥”å‹æœ¨
        wedgePositions.forEach(pos => {
          const wedge = new THREE.Mesh(wedgeGeometry, wedgeMaterial.clone());
          wedge.position.set(...pos);
          scene.add(wedge);

            const halfHeight = wedgeGeometry.parameters.height / 2;
            const halfDepth = wedgeGeometry.parameters.depth / 2;
            const fixedX = wedgeGeometry.parameters.width / 2 + 0.001;

            const sideLines = [
            // ç¬¬ä¸€æ¢ï¼šå³å´ (+X) å°è§’ç·š
            [
                new THREE.Vector3(fixedX, -halfHeight, -halfDepth),
                new THREE.Vector3(fixedX, halfHeight, halfDepth),
            ],
            // ç¬¬äºŒæ¢ï¼šå·¦å´ (-X) å°è§’ç·š
            [
                new THREE.Vector3(-fixedX, -halfHeight, -halfDepth),
                new THREE.Vector3(-fixedX, halfHeight, halfDepth),
            ],

            ];

            sideLines.forEach(points => {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4b0082 }); //ç´…è‰²
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.set(...pos); // å°é½Š wedge
            scene.add(line);
            });
        
        
        });

        // å…¨å¤¾æ¿
        const fullBoardGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.02);
        const fullBoardMaterial = new THREE.MeshPhongMaterial({
          color: 0xcccccc, // æ·ºç°è‰²
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        const fullboardX =   fullBoardGeometry.parameters.width / 2; // å…¨å¤¾æ¿Xè»¸ä½ç½®
        const fullboardY =  fullBoardGeometry.parameters.height / 2; // å…¨å¤¾
        const fullboardZ = spacing / 2 + fullBoardGeometry.parameters.depth / 2; // å…¨å¤¾æ¿Zè»¸ä½ç½®
        // å…¨å¤¾æ¿ä½ç½®
        const fullBoardPositions = [
          [fullboardX + 0.01, fullboardY + 0.01, fullboardZ], // ç¬¬ä¸€ç‰‡
          [fullboardX + 0.01, idealLength - fullBoardGeometry.parameters.height / 6, fullboardZ], // ç¬¬äºŒç‰‡
          [wedgeX - wedgeThickness/2 - 0.01 - fullboardX, fullboardY + 0.01, fullboardZ], // ç¬¬ä¸‰ç‰‡
          [fullboardX + 0.01, fullboardY + 0.01, fullboardZ - thickness-fullBoardGeometry.parameters.depth], // è£¡é¢ç¬¬ä¸€ç‰‡
          [fullboardX + 0.01, idealLength  - fullBoardGeometry.parameters.height / 6, fullboardZ- thickness-fullBoardGeometry.parameters.depth], // è£¡é¢ç¬¬äºŒç‰‡
          [wedgeX - wedgeThickness/2 - 0.01 - fullboardX, fullboardY + 0.01, fullboardZ- thickness-fullBoardGeometry.parameters.depth], // è£¡é¢ç¬¬ä¸‰ç‰‡
          [fullboardX + 0.01, fullboardY + 0.01, -fullboardZ], // èƒŒé¢ç¬¬ä¸€ç‰‡
          [fullboardX + 0.01, idealLength  - fullBoardGeometry.parameters.height / 6, -fullboardZ], // èƒŒé¢ç¬¬äºŒç‰‡
          [wedgeX - wedgeThickness/2 - 0.01 - fullboardX, fullboardY + 0.01, -fullboardZ+ thickness+fullBoardGeometry.parameters.depth], // èƒŒé¢ç¬¬ä¸‰ç‰‡
          [fullboardX + 0.01, fullboardY + 0.01, -fullboardZ+ thickness+fullBoardGeometry.parameters.depth], // èƒŒé¢è£¡é¢ç¬¬ä¸€ç‰‡
          [fullboardX + 0.01, idealLength  - fullBoardGeometry.parameters.height / 6, -fullboardZ+ thickness+fullBoardGeometry.parameters.depth], // èƒŒé¢è£¡é¢ç¬¬äºŒç‰‡
          [wedgeX - wedgeThickness/2 - 0.01 - fullboardX, fullboardY + 0.01, -fullboardZ], // èƒŒé¢è£¡é¢ç¬¬ä¸‰ç‰‡
        ];
        // å»ºç«‹å…¨å¤¾æ¿
        fullBoardPositions.forEach(pos => {
          const fullBoard = new THREE.Mesh(fullBoardGeometry, fullBoardMaterial.clone());
          fullBoard.position.set(...pos);
          scene.add(fullBoard);
        });

        // å»ºç«‹ä¸­é»é€£æ¥æŸ±
        const connectorAngle = 45* Math.PI / 180; // 45åº¦è§’
        const connectorGeometry = new THREE.BoxGeometry(shoreLength/2+thickness/6* Math.SQRT2, connectorThickness, thickness/2);
        const connectorMaterial = new THREE.MeshPhongMaterial({
          color: 0x8e44ad, // ç´«è‰²
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });

        // ä¸­é»é€£æ¥æŸ±ä½ç½®
        const connectorPositionZ = spacing / 2 + thickness/2/2+0.02; // Zè»¸ä½ç½®
        const connectorStart = new THREE.Vector3(connectorThickness/2 * Math.cos(connectorAngle),connectorThickness * Math.sin(connectorAngle)/2, connectorPositionZ );
        const connectorEnd = new THREE.Vector3(connectorThickness/2 * Math.cos(connectorAngle) + (shoreLength/2+thickness)* Math.sin(connectorAngle),connectorThickness/2 * Math.sin(connectorAngle) +(shoreLength/2+thickness)* Math.cos(connectorAngle) , connectorPositionZ  );
        const connectorDirection = new THREE.Vector3().subVectors(connectorEnd, connectorStart).normalize();
        const connectorAxis = new THREE.Vector3(1, 0, 0); 
        const connectorQuaternion = new THREE.Quaternion().setFromUnitVectors(connectorAxis, connectorDirection);
        // ä¸­é»é€£æ¥æŸ±ä½ç½®
        const connectorMidX = (connectorStart.x + connectorEnd.x) / 2; // Xè»¸ä½ç½®
        const connectorMidY = (connectorStart.y + connectorEnd.y) / 2; // Yè»¸ä½ç½®
        const connectorPositions = [
          [connectorMidX, connectorMidY, connectorPositionZ], // ç¬¬ä¸€æ ¹ä¸­é»é€£æ¥æŸ±
          [connectorMidX, connectorMidY, -connectorPositionZ],// ç¬¬äºŒæ ¹ä¸­é»é€£æ¥æŸ±
          [connectorMidX, connectorMidY, connectorPositionZ- thickness-0.02*2-thickness/2], // ç¬¬ä¸‰æ ¹ä¸­é»é€£æ¥æŸ±
          [connectorMidX, connectorMidY, -connectorPositionZ+ thickness+0.02*2+ thickness/2] // ç¬¬å››æ ¹ä¸­é»é€£æ¥æŸ±, 
        ];
        // å»ºç«‹ä¸­é»é€£æ¥æŸ±
        connectorPositions.forEach(pos => {
          const connector = new THREE.Mesh(connectorGeometry, connectorMaterial.clone());
          connector.position.set(...pos);
          connector.quaternion.copy(connectorQuaternion); // è¨­ç½®æ—‹è½‰
          scene.add(connector);
        });


        // å»ºç«‹ ä¸­é–“çš„é€£çµæŸ±    
        const connectorGeometryMid = new THREE.BoxGeometry(thickness/2,connectorThickness , spacing);
        const connectorMaterialMid = new THREE.MeshPhongMaterial({
          color: 0xff9999, // æ·ºç´…è‰²
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        // ä¸­é–“é€£çµæŸ±ä½ç½®
        const connectorPosition =[
          [bottomThickness+0.3+thickness/2/2*Math.cos(angle), idealLength + stopperWidth * Math.tan(angle)-0.3 + thickness/2/2*Math.cos(angle),0 ], // ç¬¬ä¸€æ ¹ä¸­é–“é€£çµæŸ±
          [idealLength + stopperWidth / Math.tan(angle)-0.3+thickness/2*Math.cos(angle),bottomThickness+0.3 ,0] // ç¬¬äºŒæ ¹ä¸­é–“é€£çµæŸ±
        ];
        const connectorMidAxis = new THREE.Vector3(0, 0, 1); // Yè»¸æ–¹å‘
        const connectorMidQuaternion = new THREE.Quaternion().setFromAxisAngle(connectorMidAxis, angle); // è¨­ç½®æ—‹è½‰
        // å»ºç«‹ä¸­é–“é€£çµæŸ±
        connectorPosition.forEach(pos => {
          const connectorMid = new THREE.Mesh(connectorGeometryMid, connectorMaterialMid.clone());
          connectorMid.position.set(...pos);
            connectorMid.quaternion.copy(connectorMidQuaternion); // è¨­ç½®æ—‹è½‰
          scene.add(connectorMid);
        });



        // å»ºç«‹ä¸­é–“å‚¾æ–œçš„é€£æ¥æŸ±
        const connecotrMidslopeX1 = bottomThickness+0.3+thickness/2/2*Math.cos(angle) +thickness*3/2*Math.cos(angle);
        const connecotrMidslopeX2 = idealLength + stopperWidth * Math.tan(angle)-0.3 + thickness/2/2*Math.cos(angle)-thickness*3/2*Math.cos(angle);
        const connecotrMidslopeY1 = idealLength + stopperWidth * Math.tan(angle)-0.3 + thickness/2/2*Math.sin(angle)-thickness*3/2*Math.sin(angle);
        const connecotrMidslopeY2 = bottomThickness+0.3+thickness/2/2*Math.sin(angle)+thickness*3/2*Math.sin(angle);
        const connecotrMidslopeLength = Math.sqrt(Math.pow(connecotrMidslopeX2 - connecotrMidslopeX1, 2) + Math.pow(connecotrMidslopeY2 - connecotrMidslopeY1, 2)+ Math.pow(spacing, 2));
        // å»ºç«‹ä¸­é–“å‚¾æ–œé€£æ¥æŸ±
        const connectorTiltedGeometry = new THREE.BoxGeometry(thickness/2, connectorThickness, connecotrMidslopeLength);
        const connectorTiltedMaterial = new THREE.MeshPhongMaterial({  
            color: 0xff0000, // ç´…è‰²
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
            });

        // ä¸­é–“å‚¾æ–œé€£æ¥æŸ±ä½ç½®
        const connectorTiltedStart = new THREE.Vector3(connecotrMidslopeX1, connecotrMidslopeY1, spacing/2);
        const connectorTiltedEnd = new THREE.Vector3(connecotrMidslopeX2, connecotrMidslopeY2, -spacing/2);
        const connectorTiltedAxis = new THREE.Vector3(0, 0, 1); 
        const connectorTiltedQuaternion = new THREE.Quaternion().setFromAxisAngle(connectorTiltedAxis, angle);
        const connectorTiltedDirection = new THREE.Vector3().subVectors(connectorTiltedStart , connectorTiltedEnd).normalize();
        const connectorTiltedRotation = new THREE.Quaternion().setFromUnitVectors(connectorTiltedAxis, connectorTiltedDirection);
        const finalQuaternion = connectorTiltedRotation.multiply(connectorTiltedQuaternion);
        // ä¸­é–“å‚¾æ–œé€£æ¥æŸ±ä½ç½®
        
        const connectorTiltedMidX = (connectorTiltedStart.x + connectorTiltedEnd.x) / 2; // Xè»¸ä½ç½®
        const connectorTiltedMidY = (connectorTiltedStart.y + connectorTiltedEnd.y) / 2; // Yè»¸ä½ç½®
        const connectorTiltedPositions = [
          [connectorTiltedMidX, connectorTiltedMidY, 0], // ç¬¬ä¸€æ ¹ä¸­é–“å‚¾æ–œé€£æ¥æŸ±
        ];
        // å»ºç«‹ä¸­é–“å‚¾æ–œé€£æ¥æŸ±
        connectorTiltedPositions.forEach(pos => {
          const connectorTilted = new THREE.Mesh(connectorTiltedGeometry, connectorTiltedMaterial.clone());
          connectorTilted.position.set(...pos);
          connectorTilted.quaternion.copy(finalQuaternion); // è¨­ç½®æ—‹è½‰
          scene.add(connectorTilted);
        });

        // å»ºç«‹ä¸­é–“å‚¾æ–œçš„é€£æ¥æŸ±
        const connecotrMidslopeX1_2 = bottomThickness+0.3+thickness/2/2*Math.cos(angle)+ thickness/2*Math.cos(angle);
        const connecotrMidslopeX2_2 = idealLength + stopperWidth * Math.tan(angle)-0.3 + thickness/2/2*Math.cos(angle)+thickness/2*Math.cos(angle);
        const connecotrMidslopeY1_2 = idealLength + stopperWidth * Math.tan(angle)-0.3 + thickness/2/2*Math.sin(angle)+thickness/2*Math.cos(angle);
        const connecotrMidslopeY2_2 = bottomThickness+0.3+thickness/2/2*Math.cos(angle)+thickness/2*Math.cos(angle);
        const connecotrMidslopeLength_2 = Math.sqrt(Math.pow(connecotrMidslopeX2_2 - connecotrMidslopeX1_2, 2) + Math.pow(connecotrMidslopeY2_2 - connecotrMidslopeY1_2, 2)+ Math.pow(spacing, 2));
        const connectorTiltedGeometry_2 = new THREE.BoxGeometry(thickness/2, connectorThickness, connecotrMidslopeLength_2);
        const connectorTiltedMaterial_2 = new THREE.MeshPhongMaterial({  
            color: 0xff0000, // ç´…è‰²
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
            });

        const connectorTiltedStart_2 = new THREE.Vector3(connecotrMidslopeX2_2, connecotrMidslopeY2_2, spacing/2-thickness);
        const connectorTiltedEnd_2 = new THREE.Vector3(connecotrMidslopeX1_2, connecotrMidslopeY1_2, -spacing/2+thickness);
        const connectorTiltedAxis_2 = new THREE.Vector3(0, 0, 1); 
        const connectorTiltedQuaternion_2 = new THREE.Quaternion().setFromAxisAngle(connectorTiltedAxis_2, angle);
        const connectorTiltedDirection_2 = new THREE.Vector3().subVectors(connectorTiltedStart_2 , connectorTiltedEnd_2).normalize();
        const connectorTiltedRotation_2 = new THREE.Quaternion().setFromUnitVectors(connectorTiltedAxis_2, connectorTiltedDirection_2);
        const finalQuaternion_2 = connectorTiltedRotation_2.multiply(connectorTiltedQuaternion_2);
        // ä¸­é–“å‚¾æ–œé€£æ¥æŸ±ä½ç½®
        
        const connectorTiltedMidX_2 = (connectorTiltedStart_2.x + connectorTiltedEnd_2.x) / 2; // Xè»¸ä½ç½®
        const connectorTiltedMidY_2 = (connectorTiltedStart_2.y + connectorTiltedEnd_2.y) / 2; // Yè»¸ä½ç½®
        const connectorTiltedPositions_2 = [
          [connectorTiltedMidX_2, connectorTiltedMidY_2, 0], // ç¬¬ä¸€æ ¹ä¸­é–“å‚¾æ–œé€£æ¥æŸ±
        ];
        // å»ºç«‹ä¸­é–“å‚¾æ–œé€£æ¥æŸ±
        connectorTiltedPositions_2.forEach(pos => {
          const connectorTilted = new THREE.Mesh(connectorTiltedGeometry_2, connectorTiltedMaterial_2.clone());
          connectorTilted.position.set(...pos);
          connectorTilted.quaternion.copy(finalQuaternion_2); // è¨­ç½®æ—‹è½‰
          scene.add(connectorTilted);
        });



        //ä¹‹å¾Œå¯ä»¥åˆªé™¤
        // å»ºç«‹ XYZ è»¸å‘è¼”åŠ©ç·šï¼ˆé•·åº¦å–®ä½ = å…¬å°ºï¼Œå¯èª¿æ•´ï¼‰
        //x,y,z:ç´…,ç¶ ,è—
        /*
        const axesHelper = new THREE.AxesHelper(1);  // é•·åº¦ 1 å…¬å°º
        scene.add(axesHelper);
        */
        // ä»¥ä¸‹ç‚ºç’°å¢ƒè¨­ç½®
        // ç›¸æ©Ÿä½ç½®
        const maxSize = Math.max(offsetX, height, spacing);
        camera.position.set(maxSize * 2, maxSize * 2, maxSize * 2);
        camera.lookAt(offsetX * 2, height, spacing);
        
        // æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;

        // æ¸²æŸ“
        function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();

      } else {
        result.innerHTML = `<div class="result">ç¼ºå°‘å¿…è¦è³‡æ–™ï¼Œç„¡æ³•è¨ˆç®—ï¼</div>`;
      }
    }

    function calculateBox() {
      const parsedData = {
        "æ¸¬é‡é•·åº¦": parseFloat(document.getElementById("length").value),
        "é ‚æ¿åšåº¦": parseFloat(document.getElementById("top").value),
        "åº•æ¿åšåº¦": parseFloat(document.getElementById("bottom").value),
        "æ¥”å‹æœ¨åšåº¦": parseFloat(document.getElementById("wedge").value),
        "æ”¯æ’æŸ±é–“è·": parseFloat(document.getElementById("spacing").value),
        "é€£æ¥æŸ±å¯¬åº¦": parseFloat(document.getElementById("connector").value),
      };

      let formattedMessage = "å¡«å¯«çš„è³‡æ–™ç‚º ç®±å‹æ”¯æ’\n";
      for (let key in parsedData) {
        formattedMessage += `${key}: ${parsedData[key]}, `;
      }
      formattedMessage = formattedMessage.slice(0, -2); // å»æ‰å°¾å·´

      const result = document.getElementById("dynamicResult");

      if (Object.values(parsedData).every(val => !isNaN(val))) {
        const shorelenth = parsedData["æ¸¬é‡é•·åº¦"] - parsedData["é ‚æ¿åšåº¦"] - parsedData["åº•æ¿åšåº¦"] - parsedData["æ¥”å‹æœ¨åšåº¦"] * 1.1;
        const idealShorelenth = parsedData["æ¸¬é‡é•·åº¦"] - parsedData["é ‚æ¿åšåº¦"] - parsedData["åº•æ¿åšåº¦"] - parsedData["æ¥”å‹æœ¨åšåº¦"];

        const frontAngle = Math.sqrt(
          Math.pow(parsedData["æ¸¬é‡é•·åº¦"] * 0.5 - parsedData["é€£æ¥æŸ±å¯¬åº¦"], 2) +
          Math.pow(parsedData["æ”¯æ’æŸ±é–“è·"] + 20, 2)
        ).toFixed(1);

        const sideAngle = Math.sqrt(
          Math.pow(((shorelenth - 10) * 0.5) - (parsedData["é€£æ¥æŸ±å¯¬åº¦"] * 2), 2) +
          Math.pow(parsedData["æ”¯æ’æŸ±é–“è·"], 2)
        ).toFixed(1);

        const resultHTML = `
          <div class="result">
            <div class="result-section">
              <h3>è‡¨æ™‚æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚åº•æ¿</div><div class="result-value">90 * 4</div></div>
              <div class="result-row"><div class="result-label">æ”¯æ’æŸ±</div><div class="result-value">${shorelenth.toFixed(1)} * 4</div></div>
              <div class="result-row"><div class="result-label">å…©å€å¤¾æ¿</div><div class="result-value">3å€‹</div></div>
              <div class="result-row"><div class="result-label">åŠå¤¾æ¿</div><div class="result-value">4ç‰‡</div></div>
              <div class="result-row"><div class="result-label">æ¥”å½¢æœ¨</div><div class="result-value">4çµ„</div></div>
            </div>

            <div class="result-section">
              <h3>å®Œæ•´æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚æ¿</div><div class="result-value">180 * 2</div></div>
              <div class="result-row"><div class="result-label">åº•æ¿</div><div class="result-value">180 * 2</div></div>
              <div class="result-row"><div class="result-label">æ”¯æ’æŸ±</div><div class="result-value">${shorelenth.toFixed(1)} * 4</div></div>
              <div class="result-row"><div class="result-label">æ°´å¹³é€£æ¥</div><div class="result-value">${parsedData["æ”¯æ’æŸ±é–“è·"]} * 8</div></div>
              <div class="result-row"><div class="result-label">æ­£é¢æ–œè§’</div><div class="result-value">${frontAngle} * 4</div></div>
              <div class="result-row"><div class="result-label">å´é¢æ–œè§’</div><div class="result-value">${sideAngle} * 4</div></div>
              <div class="result-row"><div class="result-label">åŠå¤¾æ¿</div><div class="result-value">12ç‰‡</div></div>
              <div class="result-row"><div class="result-label">æ¥”å½¢æœ¨</div><div class="result-value">4çµ„</div></div>
            </div>
          </div>
          <!-- ...existing code... -->
          <div id="threejs-box-viewer" style="width:100%;height:350px;"></div>
          <!-- ...existing code... -->
        `;


        result.innerHTML = resultHTML;


        // æ¸…é™¤èˆŠçš„ 3D ç•«å¸ƒ
        const oldCanvas = document.getElementById("threejs-canvas");
        if (oldCanvas) oldCanvas.remove();

        // å»ºç«‹ Three.js å ´æ™¯
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, 400/350, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(400, 350);
        renderer.domElement.id = "threejs-canvas";
        document.getElementById("threejs-box-viewer").appendChild(renderer.domElement);

        // åŠ å…¥å…‰æº
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 2, 3);
        scene.add(light);
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);

        // é ‚æ¿é•·åº¦å›ºå®š 180cm

        const topThickness = parsedData["é ‚æ¿åšåº¦"] / 100; // m
        const spacing = parsedData["æ”¯æ’æŸ±é–“è·"] / 100; // m
        const thickness = 10 / 100; // é è¨­å›ºå®š10Cm
        const height = Math.max(0.1, Math.min(idealShorelenth / 100, 10));
        const cantilever = 0.3; // æ‡¸æ¨‘ 30cm
        const defaultTopLength = 180 / 100; // åŸæœ¬å›ºå®šé•·åº¦
        const topLength = spacing * 1.5;

        // æŸ±å­ geometry
        const pillarGeometry = new THREE.BoxGeometry(thickness, height, thickness);
        const pillarMaterial = new THREE.MeshPhongMaterial({
          color: 0x1abc9c,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });

        // é ‚æ¿ geometry
        const topGeometry = new THREE.BoxGeometry(topLength, topThickness, thickness);
        const topMaterial = new THREE.MeshPhongMaterial({
          color: 0xf1c40f,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });

        // æŸ±å­ä¸­å¿ƒåˆ°é ‚æ¿é‚Šç·£è·é›¢
        const offsetX = (topLength / 2) - cantilever*(spacing/1.2) - (thickness / 2) ;

        // æŸ±å­Zè»¸åˆ†å¸ƒ
        const offsetZ = spacing / 2- (thickness / 2);
        // æŸ±å­åº§æ¨™ï¼ˆå››è§’ï¼‰
        const pillarPositions = [
          [-offsetX, height/2, -offsetZ],
          [ offsetX, height/2, -offsetZ],
          [-offsetX, height/2,  offsetZ],
          [ offsetX, height/2,  offsetZ]
        ];

        // å»ºç«‹å››æ ¹æŸ±å­
        pillarPositions.forEach(pos => {
          const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial.clone());
          pillar.position.set(...pos);
          scene.add(pillar);
        });

        // é ‚æ¿åº§æ¨™ï¼ˆå…©å¡Šï¼Œæ©«è·¨Xæ–¹å‘ï¼ŒZåˆ†åˆ¥åœ¨Â±offsetZï¼‰
        const topPositions = [
          [0, height + topThickness/2, -offsetZ],
          [0, height + topThickness/2,  offsetZ]
        ];

        topPositions.forEach(pos => {
          const topBoard = new THREE.Mesh(topGeometry, topMaterial.clone());
          topBoard.position.set(...pos);
          scene.add(topBoard);
        });


        
        // æ¥”å‹æœ¨å°ºå¯¸
        const wedgeLength = 0.3; // å›ºå®š30cm
        const wedgeHeight = parsedData["æ¥”å‹æœ¨åšåº¦"] / 100; // è®Šæ•¸ï¼Œå–®ä½m
        const wedgeThickness = thickness/2; // è·ŸæŸ±å­ä¸€æ¨£

        // æ¥”å‹æœ¨ geometryï¼ˆé•·æ–¹é«”ï¼Œä»£è¡¨å…©å€‹åŠä¸‰è§’å½¢åˆæˆï¼‰
        const wedgeGeometry = new THREE.BoxGeometry(wedgeLength, wedgeHeight, wedgeThickness);
        const wedgeMaterial = new THREE.MeshPhongMaterial({
          color: 0xe67e22,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        
        pillarPositions.forEach(pos => {
          // æŸ±å­åº•éƒ¨ Y åº§æ¨™
          const pillarBottomY = pos[1] - height / 2;//é€™æ˜¯æ­¸é›¶
          // æ¥”å‹æœ¨ä¸­å¿ƒ Y åº§æ¨™
          const wedgeY = pillarBottomY - wedgeHeight / 2;

          // æ¥”å‹æœ¨ä½ç½®ï¼šX/Z è·ŸæŸ±å­ä¸€æ¨£ï¼ŒYåœ¨æŸ±å­åº•ä¸‹
          const wedge = new THREE.Mesh(wedgeGeometry, wedgeMaterial.clone());
          wedge.position.set(pos[0], wedgeY, pos[2]);
          scene.add(wedge);

          // åŠ ä¸€æ¢æ–œç·šï¼ˆå°è§’ç·šï¼‰
          const points = [
            new THREE.Vector3(-wedgeLength/2, wedgeHeight/2, -wedgeThickness/2),
            new THREE.Vector3(wedgeLength/2, -wedgeHeight/2, wedgeThickness/2)
          ];
          const wedgeLineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const wedgeLineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
          const wedgeLine = new THREE.Line(wedgeLineGeometry, wedgeLineMaterial);
          wedgeLine.position.copy(wedge.position);
          scene.add(wedgeLine);
        });

        // åº•æ¿ geometry
        const bottomThickness = parsedData["åº•æ¿åšåº¦"] / 100; // m
        const bottomGeometry = new THREE.BoxGeometry(topLength, bottomThickness, thickness); 
        const bottomMaterial = new THREE.MeshPhongMaterial({
          color: 0xf1c40f,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });

        // è¨ˆç®—åº•æ¿Yåº§æ¨™ï¼ˆåœ¨æ‰€æœ‰wedgeåº•ä¸‹ï¼‰
        
        const bottomY = (pillarPositions[0][1] - height / 2) - wedgeHeight - bottomThickness / 2;

        // åº•æ¿åº§æ¨™ï¼ˆå…©å¡Šï¼Œæ©«è·¨Xæ–¹å‘ï¼ŒZåˆ†åˆ¥åœ¨Â±offsetZï¼‰
        const bottomPositions = [
          [0, bottomY, -offsetZ],
          [0, bottomY,  offsetZ]
        ];

        bottomPositions.forEach(pos => {
          const bottomBoard = new THREE.Mesh(bottomGeometry, bottomMaterial.clone());
          bottomBoard.position.set(...pos);
          scene.add(bottomBoard);
        });

        // ä¸­é–“é€£æ¥æŸ±å°ºå¯¸
        const connectorLength = spacing;      // æ²¿ X è»¸æ–¹å‘ï¼ˆæ”¯æ’æŸ±é–“è·ï¼‰
        const connectorThickness = parsedData["é€£æ¥æŸ±å¯¬åº¦"]/100; // æ‰€æœ‰é€£æ¥æŸ±éƒ½ç”¨é€™å€‹
        const connectorWidth = 0.05;       // æ²¿ Z è»¸ï¼Œå¯¬åº¦ï¼ˆå›ºå®š 10cmï¼‰

        // å»ºç«‹ geometry
        const connectorGeometry = new THREE.BoxGeometry(connectorLength, connectorThickness, connectorWidth);
        const connectorMaterial = new THREE.MeshPhongMaterial({
          color: 0x8e44ad, // ç´«è‰²
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });

        // ä½ç½®è¨­å®š
        const connectorX = 0;  // X è»¸å±…ä¸­ï¼ˆæ©«å‘è·¨å…©æŸ±ï¼‰
        const idealtotalY = parsedData["æ¸¬é‡é•·åº¦"]  / 100;  // ç¸½æ¸¬é‡é•·åº¦çš„ä¸€åŠ
        const connectorZ = offsetZ+thickness/2+connectorWidth/2;  // æ”¾åœ¨å…¶ä¸­ä¸€å´æŸ±å­å¤–å´ï¼ˆå¯ä»¥èª¿æ•´ç‚º +0.12 æˆ–å…¶ä»–ï¼‰                      // å±…ä¸­
        

        //å®šä½å¯¦éš›yå€¼ï¼Œä¸­å¿ƒåº§æ¨™Y
        const connectorPositionY = (topThickness+height-bottomThickness-wedgeHeight)/2
       
       
        // å®šç¾©å…©æ ¹çš„ Z ä½ç½®
        const connectorPositions = [
          [connectorX, connectorPositionY,  connectorZ],  // å³å´
          [connectorX, connectorPositionY, -connectorZ],  // å·¦å´ï¼ˆå°ç¨±ï¼‰
        ];

        // å»ºç«‹å…©æ ¹ä¸­é–“é€£æ¥æŸ±
        connectorPositions.forEach(pos => {
          const connector = new THREE.Mesh(connectorGeometry, connectorMaterial.clone());
          connector.position.set(...pos);
          scene.add(connector);
        });

        // --- å´é‚Šé€£æ¥æŸ±å°ºå¯¸ ---
        const connectorLength2 = 0.05; // æ²¿ X è»¸ï¼ˆåšåº¦ï¼‰
        const connectorWidth2 = spacing; // æ²¿ Z è»¸æ–¹å‘ï¼ˆé€£æ¥å…©æŸ±ï¼‰

        // --- å´é‚Šé€£æ¥æŸ±ä½ç½® ---
        const connectorX_2 = offsetX + thickness / 2 + connectorLength2 / 2; // X è»¸åœ¨æŸ±å­å¤–å´
        const connectorZ_2 = 0; // Z è»¸å±…ä¸­
        const connectorYup = idealtotalY / 2 - topThickness - connectorThickness /2; // å´é‚Šæ¿ä¸Šç†æƒ³å€¼
        const connectorYdown = idealtotalY / 2 - bottomThickness - wedgeHeight - connectorThickness /2 ; // å´é‚Šæ¿ä¸‹ç†æƒ³å€¼

        // --- ä½ç½®çŸ©é™£ï¼ˆå°ç¨±å·¦å³ï¼‰---
        const connectorPositions_2 = [
          [ connectorX_2,  connectorPositionY, connectorZ_2],  // å‰
          [-connectorX_2,  connectorPositionY, connectorZ_2],  // å¾Œ
          [ connectorX_2,  connectorPositionY + connectorYup - 0.01 , connectorZ_2],  // å³å´ä¸Šä¸è²¼åˆå¤šé€™1cm
          [-connectorX_2,  connectorPositionY + connectorYup - 0.01, connectorZ_2],   // å·¦å´ä¸Š
          [ connectorX_2,  connectorPositionY -connectorYdown + 0.01, connectorZ_2],  // å³å´ä¸‹ä¸è²¼åˆå¤šé€™1cm
          [-connectorX_2,  connectorPositionY -connectorYdown + 0.01 , connectorZ_2]  // å·¦å´ä¸‹
        ];

        // --- Geometry & Materialï¼ˆä½ ä¹Ÿå¯ä»¥å…±ç”¨åŸæœ¬ materialï¼‰---
        const connectorGeometry2 = new THREE.BoxGeometry(connectorLength2, connectorThickness, connectorWidth2);
        const connectorMaterial2 = new THREE.MeshPhongMaterial({
          color: 0x8e44ad, 
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });

        // --- å»ºç«‹å´é‚Šé€£æ¥æŸ± ---
        connectorPositions_2.forEach(pos => {
          const connector = new THREE.Mesh(connectorGeometry2, connectorMaterial2.clone());
          connector.position.set(...pos);
          scene.add(connector);
        });
      /////////////

        // === æ–œå‘é€£æ¥æŸ±å°ºå¯¸ ===
        const slopeWidth = parsedData["é€£æ¥æŸ±å¯¬åº¦"]/100; // æŸ±å­çš„åšåº¦ï¼ˆæ²¿ Y è»¸ï¼‰
        const slopeHeight = (topThickness + height + bottomThickness + wedgeHeight) / 2 - connectorThickness * 2;
        const slopeLength = Math.sqrt(Math.pow(spacing + cantilever * (spacing / 1.2) / 2, 2) + Math.pow(slopeHeight, 2));
        const slopeDepth = 0.05; // Z è»¸æ·±åº¦

        // å¹¾ä½•ï¼šé•·åº¦ç‚º X è»¸æ–¹å‘ï¼Œå› ç‚ºé è¨­ BoxGeometry æ˜¯æ²¿ X è»¸
        const slopeGeometry = new THREE.BoxGeometry(slopeLength, slopeWidth, slopeDepth);
        const slopeMaterial = new THREE.MeshPhongMaterial({
          color: 0xe67e22,
          transparent: true,
          opacity: 0.9
        });

        // å³å´çš„ Z åº§æ¨™
        const slopez = offsetZ + thickness / 2 + connectorWidth / 2;

        // Y é«˜ä½ç«¯é»(é€™è£¡è¦èª¿æ•´é‚è¼¯)
        const yHigh = connectorPositionY + slopeWidth / 2 + (slopeWidth / 2) * Math.sqrt(2);
        const yLow  = connectorPositionY + (topThickness + height + bottomThickness + wedgeHeight) / 2 - (slopeWidth / 2) * Math.sqrt(2);
        const yHigh_2 = connectorPositionY - slopeWidth / 2 - (slopeWidth / 2) * Math.sqrt(2);
        const yLow_2  = connectorPositionY - (topThickness + height + bottomThickness + wedgeHeight) / 2 + (slopeWidth / 2) * Math.sqrt(2);
        // èµ·é»èˆ‡çµ‚é»(é‚è¼¯ä¸è®Šæ”¹å‘¼å«è®Šæ•¸å°±å¥½)
        const slopestart = new THREE.Vector3(-offsetX, yHigh, slopez);
        const slopeend   = new THREE.Vector3(offsetX + cantilever * (spacing / 1.2) / 3 + connectorThickness / 2, yLow, slopez); // å¿…é ˆå£“éæ”¯æ’æŸ±åˆå†å¾€æ‡¸æ¨‘é è¿‘æ‰€ä»¥é€™æ¨£å¯«æ˜¯å°çš„
        const slopestart_2 = new THREE.Vector3(-offsetX, yHigh_2, slopez);
        const slopeend_2   = new THREE.Vector3(offsetX + cantilever * (spacing / 1.2) / 3 + connectorThickness / 2, yLow_2, slopez);

        // ä¸­é»èˆ‡æ—‹è½‰
        const mid = new THREE.Vector3().addVectors(slopestart, slopeend).multiplyScalar(0.5);
        const direction = new THREE.Vector3().subVectors(slopeend, slopestart).normalize();
        const xAxis = new THREE.Vector3(1, 0, 0); // é è¨­ X è»¸
        const quaternion = new THREE.Quaternion().setFromUnitVectors(xAxis, direction);
        const mid_2 = new THREE.Vector3().addVectors(slopestart_2, slopeend_2).multiplyScalar(0.5);
        const direction_2 = new THREE.Vector3().subVectors(slopeend_2, slopestart_2).normalize();
        const quaternion_2 = new THREE.Quaternion().setFromUnitVectors(xAxis, direction_2);

        // mesh å»ºç«‹
        const slope = new THREE.Mesh(slopeGeometry, slopeMaterial);
        // è¨­å®šæ–œå‘é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡ä½ç½® 
        slope.setRotationFromQuaternion(quaternion);
        slope.position.copy(mid);
        scene.add(slope);
        // åŒé¢ç¬¬äºŒæ¢æ–œå‘é€£æ¥æŸ±ä¸‹

        const slope_2 = new THREE.Mesh(slopeGeometry, slopeMaterial); 
        slope_2.setRotationFromQuaternion(quaternion_2);
        slope_2.position.copy(mid_2);
        scene.add(slope_2);
        
        //----æ–¹ä¾¿åˆ†éš”ç·š---//////////////

        // å·¦å´çš„ Z åº§æ¨™ 
        const slopez2 = -offsetZ - thickness / 2 - connectorWidth / 2;

        const slopestart2 = new THREE.Vector3(offsetX, yHigh, slopez2);
        const slopeend2   = new THREE.Vector3(-offsetX - cantilever * (spacing / 1.2) / 3 - connectorThickness / 2, yLow, slopez2);
        const slopestart2_2 = new THREE.Vector3(offsetX, yHigh_2, slopez2);
        const slopeend2_2   = new THREE.Vector3(-offsetX - cantilever * (spacing / 1.2) / 3 - connectorThickness / 2, yLow_2, slopez2);
        
        // ä¸­é»èˆ‡æ—‹è½‰ï¼ˆç¬¬äºŒæ¢ï¼‰
        const mid2 = new THREE.Vector3().addVectors(slopestart2, slopeend2).multiplyScalar(0.5);
        const direction2 = new THREE.Vector3().subVectors(slopeend2, slopestart2).normalize();
        const quaternion2 = new THREE.Quaternion().setFromUnitVectors(xAxis, direction2);
        const mid2_2 = new THREE.Vector3().addVectors(slopestart2_2, slopeend2_2).multiplyScalar(0.5);
        const direction2_2 = new THREE.Vector3().subVectors(slopeend2_2, slopestart2_2).normalize();
        const quaternion2_2 = new THREE.Quaternion().setFromUnitVectors(xAxis, direction2_2);
        // ç¬¬äºŒæ¢æ–œå‘é€£æ¥æŸ±
        const slope2 = new THREE.Mesh(slopeGeometry, slopeMaterial.clone());  
        slope2.setRotationFromQuaternion(quaternion2);
        slope2.position.copy(mid2);
        scene.add(slope2);
        // åŒé¢ç¬¬äºŒæ¢æ–œå‘é€£æ¥æŸ±ä¸‹
        const slope2_2 = new THREE.Mesh(slopeGeometry, slopeMaterial.clone());
        slope2_2.setRotationFromQuaternion(quaternion2_2);
        slope2_2.position.copy(mid2_2);
        scene.add(slope2_2);

        // ä¸­é–“çš„æ–œå‘é€£æ¥æŸ±
        // å¯¬åº¦æ²¿ç”¨è®Šæ•¸slopeWidth
        // æ·±åº¦æ²¿ç”¨è®Šæ•¸slopeDepth
        const slopeHeight2 = height/2 - slopeWidth*1.5 - slopeWidth * Math.sqrt(2) /2 ; // é«˜åº¦èª¿æ•´ç‚ºæŸ±å­é«˜åº¦çš„ä¸€åŠæ¸›å»3/2è®Šæ•¸é•·ï¼Œæ‰£æ‰ä¸Šæ¿çš„0.01
        const slopeLength2 = Math.sqrt(Math.pow(spacing-connectorThickness, 2) + Math.pow(slopeHeight2, 2));
        const slopeGeometry2 = new THREE.BoxGeometry(slopeDepth, slopeWidth, slopeLength2);
        const slopeMaterial2 = new THREE.MeshPhongMaterial({
          color: 0xe67e22,
          transparent: true,
          opacity: 0.9
        });
        const slopeX3 = offsetX + thickness / 2 + connectorWidth / 2; // xç•¶çªå‡ºçš„å®šä½é»ï¼Œæ˜¯æ­£ç¢ºçš„
        // Y é«˜ä½ç«¯é»(ä¸åŒé‚è¼¯)
        const yHigh2 = connectorPositionY + idealtotalY / 2 - topThickness - slopeWidth - (slopeWidth / 2) * Math.sqrt(2) -0.02 ;
        const yLow2  = connectorPositionY + slopeWidth / 2 + (slopeWidth / 2) * Math.sqrt(2) + 0.02;
        const yHigh2_2 = connectorPositionY - idealtotalY / 2 + bottomThickness + wedgeHeight + slopeWidth + (slopeWidth / 2) * Math.sqrt(2) +0.02 ;
        const yLow2_2  = connectorPositionY - slopeWidth / 2 - (slopeWidth / 2) * Math.sqrt(2) -0.02 ;
        // èµ·é»èˆ‡çµ‚é»(é€™è£¡æ”¹ç”¨3å¾€å¾Œç”¨4æ–¹ä¾¿åˆ†è¾¨è±¡é™)
        const slopestart3 = new THREE.Vector3(slopeX3, yLow2, offsetZ  );
        const slopeend3   = new THREE.Vector3(slopeX3, yHigh2, -offsetZ  );
        const slopestart3_2 = new THREE.Vector3(slopeX3, yLow2_2, offsetZ );
        const slopeend3_2   = new THREE.Vector3(slopeX3, yHigh2_2, -offsetZ );
        // ä¸­é»èˆ‡æ—‹è½‰
        const mid3 = new THREE.Vector3().addVectors(slopestart3, slopeend3).multiplyScalar(0.5);
        const direction3 = new THREE.Vector3().subVectors(slopeend3, slopestart3).normalize();
        const zAxis = new THREE.Vector3(0, 0, 1); // æ›æˆ Z è»¸ç‚ºä¸»
        const quaternion3 = new THREE.Quaternion().setFromUnitVectors(zAxis, direction3);
        const mid3_2 = new THREE.Vector3().addVectors(slopestart3_2, slopeend3_2).multiplyScalar(0.5);
        const direction3_2 = new THREE.Vector3().subVectors(slopeend3_2, slopestart3_2).normalize();
        const quaternion3_2 = new THREE.Quaternion().setFromUnitVectors(zAxis, direction3_2);
        // mesh å»ºç«‹
        const slope3 = new THREE.Mesh(slopeGeometry2, slopeMaterial2);
        // è¨­å®šä¸­é–“æ–œå‘é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡ä½ç½®
        slope3.setRotationFromQuaternion(quaternion3);
        slope3.position.copy(mid3);
        scene.add(slope3);
        // åŒé¢ç¬¬äºŒæ¢ä¸­é–“æ–œå‘é€£æ¥æŸ±ä¸‹
        const slope3_2 = new THREE.Mesh(slopeGeometry2, slopeMaterial2.clone());
        slope3_2.setRotationFromQuaternion(quaternion3_2);
        slope3_2.position.copy(mid3_2);
        scene.add(slope3_2);

        // -----æ–¹ä¾¿åˆ†éš”ç·š----- //
        const slopeX4 = -offsetX - thickness / 2 - connectorWidth / 2; // ä¸­é–“çš„ x è»¸ä½ç½®ç‚º 0
        const slopestart4 = new THREE.Vector3(slopeX4, yLow2, -offsetZ );
        const slopeend4   = new THREE.Vector3(slopeX4, yHigh2, offsetZ );
        const slopestart4_2 = new THREE.Vector3(slopeX4, yLow2_2, -offsetZ );
        const slopeend4_2   = new THREE.Vector3(slopeX4, yHigh2_2, offsetZ );
        // ä¸­é»èˆ‡æ—‹è½‰ï¼ˆç¬¬äºŒæ¢ï¼‰
        const mid4 = new THREE.Vector3().addVectors(slopestart4, slopeend4).multiplyScalar(0.5);
        const direction4 = new THREE.Vector3().subVectors(slopeend4, slopestart4).normalize();
        const quaternion4 = new THREE.Quaternion().setFromUnitVectors(zAxis, direction4);
        const mid4_2 = new THREE.Vector3().addVectors(slopestart4_2, slopeend4_2).multiplyScalar(0.5);
        const direction4_2 = new THREE.Vector3().subVectors(slopeend4_2, slopestart4_2).normalize();
        const quaternion4_2 = new THREE.Quaternion().setFromUnitVectors(zAxis, direction4_2);
        // ç¬¬äºŒæ¢æ–œå‘é€£æ¥æŸ±
        const slope4 = new THREE.Mesh(slopeGeometry2, slopeMaterial2.clone());  
        slope4.setRotationFromQuaternion(quaternion4);
        slope4.position.copy(mid4);
        scene.add(slope4);
        // åŒé¢ç¬¬äºŒæ¢æ–œå‘é€£æ¥æŸ±ä¸‹
        const slope4_2 = new THREE.Mesh(slopeGeometry2, slopeMaterial2.clone());
        slope4_2.setRotationFromQuaternion(quaternion4_2);
        slope4_2.position.copy(mid4_2);
        scene.add(slope4_2);

        // å¤¾æ¿æ²¿ç”¨è®Šæ•¸heightã€æ²¿ç”¨
        const boardHeight = 0.3; // å¤¾æ¿é«˜åº¦
        const boardWidth = 0.02; // å¤¾æ¿åšåº¦0.02
        const boardLength = 0.15; // å¤¾æ¿é•·åº¦
        const boardGeometry = new THREE.BoxGeometry(boardLength, boardHeight, boardWidth);
        const boardMaterial = new THREE.MeshPhongMaterial({
          color: 0x8B4513, // è¦è·Ÿå‰é¢é¡è‰²æœ‰å°æ¯”çš„é¡è‰²
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        // å¤¾æ¿ä½ç½®è¨ˆç®—
        const boardOffsetY_up = connectorPositionY + idealtotalY / 2 - connectorThickness / 2 - topThickness - 0.01; // ä¸Šæ–¹å¤¾æ¿ä½ç½®
        const boardOffsetY_down = connectorPositionY - idealtotalY / 2 + bottomThickness  + connectorThickness / 2 + 0.01; // ä¸‹æ–¹å¤¾æ¿ä½ç½®
        const boardOffsetX = (boardLength - thickness) / 2; // X è»¸åç§»é‡
        const boardPositions = [
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_up, offsetZ + thickness / 2], // ä¸Šæ–¹å·¦å´
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_down, offsetZ + thickness / 2], // ä¸‹æ–¹å·¦å´
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_up, offsetZ - thickness / 2], // ä¸Šæ–¹å·¦å´èƒŒé¢
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_down, offsetZ - thickness / 2], // ä¸‹æ–¹å·¦å´èƒŒé¢
          [offsetX - boardOffsetX - 0.01, boardOffsetY_up, offsetZ - thickness / 2], // ä¸Šæ–¹å³å´èƒŒé¢
          [offsetX - boardOffsetX - 0.01, boardOffsetY_down, offsetZ - thickness / 2], // ä¸‹æ–¹å³å´èƒŒé¢
          [offsetX - boardOffsetX - 0.01, boardOffsetY_up, -offsetZ - thickness / 2], // ä¸Šæ–¹å³å´
          [offsetX - boardOffsetX - 0.01, boardOffsetY_down, -offsetZ - thickness / 2],  // ä¸‹æ–¹å³å´
          [offsetX - boardOffsetX - 0.01, boardOffsetY_up, -offsetZ + thickness / 2], // ä¸Šæ–¹å³å´èƒŒé¢
          [offsetX - boardOffsetX - 0.01, boardOffsetY_down, -offsetZ + thickness / 2],  // ä¸‹æ–¹å³å´èƒŒé¢
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_up, -offsetZ + thickness / 2], // ä¸Šæ–¹å³å´èƒŒé¢
          [-offsetX + boardOffsetX + 0.01, boardOffsetY_down, -offsetZ + thickness / 2],  // ä¸‹æ–¹å³å´èƒŒé¢
        ];

        // å»ºç«‹å¤¾æ¿ Mesh
        boardPositions.forEach(pos => {
          const board = new THREE.Mesh(boardGeometry, boardMaterial);
          board.position.set(...pos);
          scene.add(board);
        });

        /*
        //ä¹‹å¾Œå¯ä»¥åˆªé™¤
        // å»ºç«‹ XYZ è»¸å‘è¼”åŠ©ç·šï¼ˆé•·åº¦å–®ä½ = å…¬å°ºï¼Œå¯èª¿æ•´ï¼‰
        //x,y,z:ç´…,ç¶ ,è—
        const axesHelper = new THREE.AxesHelper(1);  // é•·åº¦ 1 å…¬å°º
        scene.add(axesHelper);
        */
        
        // ç›¸æ©Ÿä½ç½®
        const maxSize = Math.max(spacing, height, thickness);
        camera.position.set(maxSize * 2, maxSize * 2, maxSize * 2);
        camera.lookAt(0, 0, 0);

        // æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;

        // æ¸²æŸ“
        function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();



      } else {
        result.innerHTML = `<div class="result">ç¼ºå°‘å¿…è¦è³‡æ–™ï¼Œç„¡æ³•è¨ˆç®—ï¼</div>`;
      }
    }


    function calculateFloor() {
      const parsedData = {
        "æ¸¬é‡é•·åº¦": parseFloat(document.getElementById("length").value),
        "é ‚æ¿åšåº¦": parseFloat(document.getElementById("top").value),
        "åº•æ¿åšåº¦": parseFloat(document.getElementById("bottom").value),
        "æ”¯æ’æŸ±é–“è·": parseFloat(document.getElementById("spacing").value),
        "é€£æ¥æŸ±å¯¬åº¦": parseFloat(document.getElementById("connector").value),
        "æ­¢æª”å¯¬åº¦": parseFloat(document.getElementById("stopper").value),
        "è§’åº¦": parseFloat(document.getElementById("angle").value),
      };

      const result = document.getElementById("dynamicResult");

      // æª¢æŸ¥è¼¸å…¥è³‡æ–™æ˜¯å¦å®Œæ•´
      if (Object.values(parsedData).every(val => !isNaN(val))) {
        const rad = parsedData["è§’åº¦"] * Math.PI / 180;

        const temporaryshorelenth = (parsedData["æ¸¬é‡é•·åº¦"] + 5 - parsedData["é ‚æ¿åšåº¦"] - (parsedData["åº•æ¿åšåº¦"] / Math.cos(rad)) - 1).toFixed(1);
        const shorelenth = (parsedData["æ¸¬é‡é•·åº¦"] - parsedData["é ‚æ¿åšåº¦"] - (parsedData["åº•æ¿åšåº¦"] / Math.cos(rad)) + 1).toFixed(1);
        const shortshorelenth = (parsedData["æ¸¬é‡é•·åº¦"] - parsedData["é ‚æ¿åšåº¦"] - (parsedData["åº•æ¿åšåº¦"] / Math.cos(rad)) - ((parsedData["æ”¯æ’æŸ±é–“è·"] - 10) * Math.tan(rad)) + 1).toFixed(1);
        const bottomlenth = (parsedData["æ”¯æ’æŸ±é–“è·"] / Math.cos(rad) + 30 + 30 + 45).toFixed(1);

        result.innerHTML = `
          <div class="result">
            <div class="result-section">
              <h3>è‡¨æ™‚æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚æ¿</div><div class="result-value">90 * 2</div></div>
              <div class="result-row"><div class="result-label">æ”¯æ’æŸ±</div><div class="result-value">${temporaryshorelenth} * 2</div></div>
              <div class="result-row"><div class="result-label">æ§½å¼åŸºåº§</div><div class="result-value">2å€‹</div></div>
              <div class="result-row"><div class="result-label">å…¨å¤¾æ¿</div><div class="result-value">2ç‰‡</div></div>
              <div class="result-row"><div class="result-label">é‹¼ç­‹</div><div class="result-value">4æ ¹</div></div>
            </div>

            <div class="result-section">
              <h3>å®Œæ•´æ”¯æ’</h3>
              <div class="result-row"><div class="result-label">é ‚æ¿</div><div class="result-value">180 * 2</div></div>
              <div class="result-row"><div class="result-label">åº•æ¿</div><div class="result-value">${bottomlenth} * 2</div></div>
              <div class="result-row"><div class="result-label">é•·æ”¯æ’æŸ±</div><div class="result-value">${shorelenth} * 2</div></div>
              <div class="result-row"><div class="result-label">çŸ­æ”¯æ’æŸ±</div><div class="result-value">${shortshorelenth} * 2</div></div>
              <div class="result-row"><div class="result-label">æ°´å¹³é€£æ¥</div><div class="result-value">${parsedData["æ”¯æ’æŸ±é–“è·"]} * 4</div></div>
              <div class="result-row"><div class="result-label">æ­¢æª”</div><div class="result-value">4å€‹</div></div>
              <div class="result-row"><div class="result-label">åŠå¤¾æ¿</div><div class="result-value">8ç‰‡</div></div>
              <div class="result-row"><div class="result-label">é‹¼ç­‹</div><div class="result-value">4æ ¹</div></div>
              <div class="result-row"><div class="result-label">å°è§’é€£æ¥æŸ±</div><div class="result-value">ç¾å ´é‡æ¸¬ * 4</div></div>
              <div class="result-row"><div class="result-label">å´é‚Šé€£æ¥æŸ±</div><div class="result-value">ç¾å ´é‡æ¸¬ * 4</div></div>
            </div>
          </div>
          <!-- ...existing code... -->
          <div id="threejs-box-viewer" style="width:100%;height:350px;"></div>
          <!-- ...existing code... -->
        `;



        // æ¸…é™¤èˆŠçš„ 3D ç•«å¸ƒ
        const oldCanvas = document.getElementById("threejs-canvas");
        if (oldCanvas) oldCanvas.remove();

        // å»ºç«‹ Three.js å ´æ™¯
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, 400/350, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(400, 350);
        renderer.domElement.id = "threejs-canvas";
        document.getElementById("threejs-box-viewer").appendChild(renderer.domElement);

        // åŠ å…¥å…‰æº
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 2, 3);
        scene.add(light);
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        // ä»¥ä¸Šç‚ºç’°å¢ƒè¨­ç½®
        // å®£å‘Šè¨­å®šè®Šæ•¸
        const spacing = parsedData["æ”¯æ’æŸ±é–“è·"] / 100; // m
        const totalLength = parsedData["æ¸¬é‡é•·åº¦"] / 100; // m
        const shoreLength = totalLength - parsedData["é ‚æ¿åšåº¦"] / 100 - (parsedData["åº•æ¿åšåº¦"] / Math.cos(rad)) / 100 ; // m
        const shortshoreLength = (shoreLength / Math.tan(rad) - (spacing - 0.1)) * Math.tan(rad) ;// m
        const bottomLength = (parsedData["æ”¯æ’æŸ±é–“è·"] / Math.cos(rad) + 30 + 30 + 45) / 100; // m
        const topLength = 1.8 * spacing /1.2; // é ‚æ¿é•·åº¦ï¼Œå‡è¨­ 1.8 m
        const thickness = 0.1; // 10å…¬åˆ†
        const cantilever = 0.3 * spacing /1.2; // 30å…¬åˆ†æ‡¸æ¨‘
        const topThickness = parsedData["é ‚æ¿åšåº¦"] / 100; // m
        const bottomThickness = parsedData["åº•æ¿åšåº¦"] / 100; // m
        const stopperWidth = parsedData["æ­¢æª”å¯¬åº¦"] / 100; // m
        const angle = parsedData["è§’åº¦"] * Math.PI / 180; // è½‰æ›ç‚ºå¼§åº¦
        
        const height = totalLength / 2; // æ”¯æ’æŸ±é«˜åº¦ï¼Œå‡è¨­
        // è¨­å®šæŸ±å­é–“è·
        const offsetX = bottomLength / 2 ;

        // æŸ±å­Zè»¸é–“è·
        const offsetZ = spacing / 2- (thickness / 2);

        // æ­¸é›¶Yè»¸
        const offsetY = bottomThickness / 2 ;


        //åº•æ¿
        const bottomWidth = 0.1; // å›ºå®šåšåº¦ 10cm
        const bottomGeometry = new THREE.BoxGeometry(bottomLength, bottomThickness, bottomWidth);

        const bottomMaterial = new THREE.MeshPhongMaterial({
          color: 0xf1c40f, // é»ƒè‰²
          transparent: false, //ä¸é€æ˜
          opacity: 1,
          side: THREE.DoubleSide,

        });
        // åº•æ¿ä½ç½®
        const bottomPositions = [
          [0, offsetY, offsetZ], // å‰
          [0, offsetY, -offsetZ] // å¾Œ
        ];
        

        bottomPositions.forEach(position => {
          const bottomMesh = new THREE.Mesh(bottomGeometry, bottomMaterial);
          bottomMesh.position.set(...position);
          scene.add(bottomMesh);
        });
        
        //æ”¯æ’æŸ±short 
        const shortpillarGeometry = new THREE.BoxGeometry(thickness, shortshoreLength, thickness-0.0001); //  // æ¸›å°‘åšåº¦ä»¥é¿å…æ·±åº¦è¡çª
        const shortpillarMaterial = new THREE.MeshPhongMaterial({
          color: 0x3498db, // è—è‰²
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,

        });
        // æ”¯æ’æŸ±
        const pillarGeometry = new THREE.BoxGeometry(thickness, shoreLength, thickness - 0.0001); // æ¸›å°‘åšåº¦ä»¥é¿å…æ·±åº¦è¡çª
        const pillarMaterial = new THREE.MeshPhongMaterial({
          color: 0x2ecc71, // ç¶ è‰²
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,

        });
        // è¨ˆç®—æ”¯æ’æŸ±ä½ç½®
        const shortPillarX = -offsetX + cantilever  + thickness * (1/Math.cos(angle) - Math.cos(angle)/2) ; // çŸ­Xè»¸åº•æ¿ä½ç½®
        const shortPillarX_2 = shortPillarX - shortshoreLength * Math.sin(angle); // çŸ­xè»¸é ‚æ¿ä½ç½®
        const shortPillarY = offsetY + bottomThickness / 2 - thickness/2 * Math.sin(angle); // çŸ­yè»¸ä½ç½®
        const shortPillarY_2 = shortPillarY + shortshoreLength * Math.cos(angle) ; // çŸ­yè»¸é ‚æ¿ä½ç½®
        const shortPillarstart = new THREE.Vector3(shortPillarX, shortPillarY, offsetZ);
        const shortPillarend   = new THREE.Vector3(shortPillarX_2, shortPillarY_2, offsetZ);
        const shortPillarXmid = (shortPillarX + shortPillarX_2) / 2; // çŸ­æ”¯æ’æŸ±ä¸­é»X
        const shortPillarYmid = (shortPillarY + shortPillarY_2) / 2; // çŸ­æ”¯æ’æŸ±ä¸­é»Y
        // è¨ˆç®—çŸ­æ”¯æ’æŸ±çš„ä¸­é»å’Œæ—‹è½‰
        const shortPillarmid = new THREE.Vector3(shortPillarXmid, shortPillarYmid, offsetZ);
        const shortPillarxAxis = new THREE.Vector3(0, 0, 1); // é è¨­ z è»¸
        const shortPillarquaternion = new THREE.Quaternion().setFromAxisAngle(shortPillarxAxis, angle);
        
        const shortPillarPositions = [
          [shortPillarXmid, shortPillarYmid, offsetZ], // å‰å³
          [shortPillarXmid, shortPillarYmid, -offsetZ] // å¾Œå³
        ];
        // å»ºç«‹çŸ­æ”¯æ’æŸ± Mesh
        shortPillarPositions.forEach(pos => {
          const shortPillar = new THREE.Mesh(shortpillarGeometry, shortpillarMaterial.clone());
          shortPillar.position.set(...pos);
          shortPillar.setRotationFromQuaternion(shortPillarquaternion);
          scene.add(shortPillar);
        });


        // é•·è»¸
        const PillarX = shortPillarX + (spacing-0.1) / Math.cos(angle); // é•·åº•æ¿xè»¸ä½ç½®
        const PillarX_2 = PillarX - shoreLength * Math.sin(angle); // é•·é ‚æ¿xè»¸ä½ç½®
        const PillarY = offsetY + bottomThickness / 2 - thickness/2 * Math.sin(angle); // é•·yè»¸ä½ç½®
        const PillarY_2 = PillarY + shoreLength * Math.cos(angle); // é•·yè»¸é ‚æ¿ä½ç½®
        const Pillarstart = new THREE.Vector3(PillarX, PillarY, offsetZ);
        const Pillarend   = new THREE.Vector3(PillarX_2, PillarY_2, offsetZ);
        const PillarXmid = (PillarX + PillarX_2) / 2; // é•·æ”¯æ’æŸ±ä¸­é»X
        const PillarYmid = (PillarY + PillarY_2) / 2; // é•·æ”¯æ’æŸ±ä¸­é»Y
        // è¨ˆç®—é•·æ”¯æ’æŸ±çš„ä¸­é»å’Œæ—‹è½‰
        const Pillarmid = new THREE.Vector3(PillarXmid, PillarYmid, offsetZ);
        const PillarxAxis = new THREE.Vector3(0, 0, 1); // é è¨­ z è»¸
        const Pillarquaternion = new THREE.Quaternion().setFromAxisAngle(PillarxAxis, angle);
        // è¨ˆç®—æ”¯æ’æŸ±ä½ç½®
        const pillarPositions = [
          [PillarXmid, PillarYmid, offsetZ], // å‰å³
          [PillarXmid, PillarYmid, -offsetZ] // å¾Œå³
        ];
        // å»ºç«‹æ”¯æ’æŸ± Mesh
        pillarPositions.forEach(pos => {
          const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial.clone());
          pillar.position.set(...pos);
          pillar.setRotationFromQuaternion(Pillarquaternion);
          scene.add(pillar);
        });


        // --- é ‚æ¿ geometry ---
        const topGeometry = new THREE.BoxGeometry(topLength, topThickness, thickness);
        const topMaterial = new THREE.MeshPhongMaterial({
          color: 0xe74c3c, // ç´…è‰²
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        // é ‚æ¿ä½ç½®è¨ˆç®—
        const topX = (shortPillarX_2 + PillarX_2) / 2 -  topThickness / 2  * Math.sin(angle) ; // é ‚æ¿Xè»¸ä½ç½®
        const topY = (shortPillarY_2 + PillarY_2) / 2 +  topThickness / 2 * Math.cos(angle);  // é ‚æ¿Yè»¸ä½ç½®

        const topPositions = [
          [topX , topY, offsetZ], // å‰å³
          [topX , topY, -offsetZ] // å¾Œå³
        ];
        // å»ºç«‹é ‚æ¿ Mesh
        topPositions.forEach(pos => {
          const topMesh = new THREE.Mesh(topGeometry, topMaterial.clone());
          topMesh.position.set(...pos);
          topMesh.setRotationFromQuaternion(Pillarquaternion);
          scene.add(topMesh);
        });

        // å»ºç«‹å´é‚Šé€£æ¥æŸ±
        const connectorWidth = parsedData["é€£æ¥æŸ±å¯¬åº¦"] / 100; // m
        const connectorThickness = 0.05; // å‡è¨­é€£æ¥æŸ±åšåº¦ 
        const connectorLength = Math.sqrt(Math.pow((PillarX - shortPillarX_2 ),2)+Math.pow((shortPillarY_2),2)) + thickness * Math.sqrt(2) ; 
        const connectorGeometry = new THREE.BoxGeometry(connectorLength, connectorWidth, connectorThickness);
        const connectorMaterial = new THREE.MeshPhongMaterial({
          color: 0x8e44ad, // ç´«è‰²
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        // è¨ˆç®—é€£æ¥æŸ±ä½ç½®

        const connectorPositionY = (PillarY + shortPillarY_2) / 2 ; // é€£æ¥æŸ±Yè»¸ä½ç½®
        const connectorPositionX = (PillarX + shortPillarX_2) / 2 ; // é€£æ¥æŸ±Xè»¸ä½ç½®
        const connectorPositionZ = offsetZ + thickness/2 + connectorThickness / 2;

        // é€£æ¥æŸ±æ•¸å€¼
        const connectorStart = new THREE.Vector3(shortPillarX_2 - thickness -0.01, shortPillarY_2  , connectorPositionZ );
        const connectorEnd= new THREE.Vector3(PillarX + thickness, PillarY +0.01  , connectorPositionZ );
        const connectorMid = new THREE.Vector3().addVectors(connectorStart, connectorEnd).multiplyScalar(0.5);
        const connectorDirection = new THREE.Vector3().subVectors(connectorStart, connectorEnd).normalize();
        const connectorAxis = new THREE.Vector3(1, 0, 0); // é è¨­ z è»¸
        const connectorquaternion = new THREE.Quaternion().setFromUnitVectors(connectorAxis, connectorDirection);
        /*
        //è½‰æ›è§’åº¦ç¯„ä¾‹
        const connectorangle = connectorAxis.angleTo(connectorDirection) * (180 / Math.PI); // å›å‚³å€¼ç‚ºå¼§åº¦
        console.log(connectorangle)
        */
        const connectorPositions = [
          [connectorPositionX, connectorPositionY, connectorPositionZ], // å‰å³
          [connectorPositionX, connectorPositionY, -connectorPositionZ] // å¾Œå³
        ];
        // å»ºç«‹é€£æ¥æŸ± Mesh
        connectorPositions.forEach(pos => {
          const connector = new THREE.Mesh(connectorGeometry, connectorMaterial.clone());
          connector.position.set(...pos);
          connector.setRotationFromQuaternion(connectorquaternion);
          scene.add(connector);
        });

        //å¦ä¸€æ–¹å‘å´é‚Šé€£æ¥æŸ±
        const connectorPositionY_bk = (PillarY_2 + shortPillarY) / 2 ; // é€£æ¥æŸ±Yè»¸ä½ç½®
        const connectorPositionX_bk = (PillarX_2 + shortPillarX) / 2 ; // é€£æ¥æŸ±Xè»¸ä½ç½®
        const connectorPositionZ_bk = offsetZ - thickness/2 - connectorThickness / 2;
        const connectorLength_bk = Math.sqrt(Math.pow((PillarX_2 - shortPillarX), 2) + Math.pow((PillarY_2), 2)) + (connectorWidth - thickness) / 2 * Math.sqrt(2);
        const connectorGeometry_bk = new THREE.BoxGeometry(connectorLength_bk, connectorWidth, connectorThickness);
        const connectorMaterial_bk = new THREE.MeshPhongMaterial({
          color: 0x8e44ad, // ç´«è‰²
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        // å¾Œé¢é€£æ¥æŸ±æ•¸å€¼
        const connectorStart_bk = new THREE.Vector3(PillarX_2  + 0.01, PillarY_2 , connectorPositionZ_bk);
        const connectorEnd_bk = new THREE.Vector3(shortPillarX , shortPillarY + 0.01 , connectorPositionZ_bk);
        const connectorMid_bk = new THREE.Vector3().addVectors(connectorStart_bk, connectorEnd_bk).multiplyScalar(0.5);
        const connectorDirection_bk = new THREE.Vector3().subVectors(connectorStart_bk, connectorEnd_bk).normalize();
        const connectorAxis_bk = new THREE.Vector3(1, 0, 0); // é è¨­ z è»¸
        const connectorquaternion_bk = new THREE.Quaternion().setFromUnitVectors(connectorAxis_bk, connectorDirection_bk); 

        const connectorPositions_bk = [
          [connectorPositionX_bk, connectorPositionY_bk, connectorPositionZ_bk], // å‰å³
          [connectorPositionX_bk, connectorPositionY_bk, -connectorPositionZ_bk] // å¾Œå³
        ];

        // å»ºç«‹å¾Œé¢é€£æ¥æŸ± Mesh
        connectorPositions_bk.forEach(pos => {
          const connector = new THREE.Mesh(connectorGeometry_bk, connectorMaterial_bk.clone());
          connector.position.set(...pos);
          connector.setRotationFromQuaternion(connectorquaternion_bk);
          scene.add(connector);
        });



        
        // å»ºç«‹æ­¢æª”
        const stopperGeometry = new THREE.BoxGeometry(0.45, stopperWidth, thickness);
        const stopperMaterial = new THREE.MeshPhongMaterial({
          color: 0x95a5a6, // ç°è‰²
          transparent: false,
          opacity: 1,
          side: THREE.DoubleSide
        });
        // æ­¢æª”ä½ç½®è¨ˆç®—
        const stopperY = offsetY + bottomThickness / 2 + stopperWidth / 2;
        const stopperX = -offsetX + cantilever + thickness / Math.cos(angle) + 0.45 /2  - stopperWidth * Math.tan(angle); // æ­¢æª”Xè»¸ä½ç½®
        const stopperX_2 = stopperX + (spacing-0.1) / Math.cos(angle);
        const stopperPositions = [
          [stopperX , stopperY, offsetZ], // å‰å·¦
          [stopperX, stopperY, -offsetZ],// å‰å³
          [stopperX_2, stopperY, offsetZ], // å¾Œå·¦
          [stopperX_2, stopperY, -offsetZ] // å¾Œå³
        ];
        // å»ºç«‹æ­¢æª” Mesh
        stopperPositions.forEach(pos => {
          const stopperMesh = new THREE.Mesh(stopperGeometry, stopperMaterial.clone());
          stopperMesh.position.set(...pos);
          scene.add(stopperMesh);
        });

        // å»ºç«‹ä¸­é–“çš„æ°´å¹³é€£æ¥æŸ±
        const connectorMidGeometry = new THREE.BoxGeometry(connectorThickness, connectorWidth, spacing  );
        const connectorMidMaterial = new THREE.MeshPhongMaterial({
          color: 0xe67e22, // æ©™è‰²
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        // ä¸­é–“é€£æ¥æŸ±ä½ç½®è¨ˆç®—
        const connectormidY = PillarY + thickness/2 * Math.sin(angle) + connectorThickness/2 * Math.sin(angle) + (stopperWidth / Math.cos(angle) + 0.01) * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Yè»¸ä½ç½®
        const connectormidY_2 = connectormidY + connectorWidth* Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Yè»¸é ‚æ¿ä½ç½®
        const connectormidX = PillarX + thickness/2 * Math.cos(angle) + connectorThickness/2 * Math.cos(angle) - (stopperWidth / Math.cos(angle) + 0.01) * Math.sin(angle) ; // é€£æ¥æŸ±Xè»¸ä½ç½®
        const connectormidX_2 = connectormidX - connectorWidth * Math.sin(angle); // é€£æ¥æŸ±Xè»¸é ‚æ¿ä½ç½®
        //PillarX + thickness/2 * Math.cos(angle) + connectorThickness/2 * Math.cos(angle) - (stopperWidth / Math.cos(angle)) æ­¤ç‚ºä¸­é–“å¤¾æ¿èˆ‡åº•æ¿äº¤ç•Œé»
        //(stopperWidth / Math.cos(angle))å–®ä½ç‚ºé•·åº¦
        const connectmidXmid = (connectormidX + connectormidX_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Xè»¸ä½ç½®
        const connectormidYmid = (connectormidY + connectormidY_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Yè»¸ä½ç½®
        //ä¸Šé¢çš„ä¸­é–“é€£æ¥æŸ±ä½ç½®
        const connectormidY2 = PillarY + thickness/2 * Math.sin(angle) + connectorThickness/2 * Math.sin(angle) + (shoreLength - connectorWidth - 0.01) * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Zè»¸ä½ç½®
        const connectormidY2_2 = connectormidY2 + connectorWidth * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Zè»¸é ‚æ¿ä½ç½®
        const connectormidX2 = PillarX + thickness/2 * Math.cos(angle) + connectorThickness/2 * Math.cos(angle) - (shoreLength - connectorWidth - 0.01) * Math.sin(angle); // é€£æ¥æŸ±Zè»¸ä½ç½®
        const connectormidX2_2 = connectormidX2 - connectorWidth * Math.sin(angle); // é€£æ¥æŸ±Zè»¸é ‚æ¿ä½ç½®
        const connectmidXmid_2 = (connectormidX2 + connectormidX2_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Zè»¸ä½ç½®
        const connectormidYmid_2 = (connectormidY2 + connectormidY2_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Zè»¸ä½ç½®
        // åé¢ä¸­é–“é€£æ¥æŸ±ä½ç½®è¨ˆç®—
        const connectormidY_bk = shortPillarY + thickness/2 * Math.sin(angle) + connectorThickness/2 * Math.sin(angle) + (stopperWidth / Math.cos(angle) + 0.01) * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Yè»¸ä½ç½®
        const connectormidY_bk_2 = connectormidY_bk + connectorWidth * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Yè»¸é ‚æ¿ä½ç½®
        const connectormidX_bk = connectormidX - spacing / Math.cos(angle) - connectorThickness / Math.cos(angle); // é€£æ¥æŸ±Xè»¸ä½ç½®
        const connectormidX_bk_2 = connectormidX_bk - connectorWidth * Math.sin(angle); // é€£æ¥æŸ±Xè»¸é ‚æ¿ä½ç½®
        const connectmidXmid_bk = (connectormidX_bk + connectormidX_bk_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Xè»¸ä½ç½®
        const connectormidYmid_bk = (connectormidY_bk + connectormidY_bk_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Yè»¸ä½ç½®
        // åé¢ä¸Šé¢ä¸­é–“é€£æ¥æŸ±ä½ç½®è¨ˆç®—
        const connectormidY_bk2 = shortPillarY + thickness/2 * Math.sin(angle) + connectorThickness/2 * Math.sin(angle) + (shortshoreLength - connectorWidth - 0.01) * Math.cos(angle) - (thickness + connectorThickness) * Math.sin(angle) ; // ä¸­é–“é€£æ¥æŸ±Zè»¸ä½ç½®
        const connectormidY_bk2_2 = connectormidY_bk2 + connectorWidth * Math.cos(angle); // ä¸­é–“é€£æ¥æŸ±Zè»¸é ‚æ¿ä½ç½®
        const connectormidX_bk2 = shortPillarX + thickness/2 * Math.cos(angle) + connectorThickness/2 * Math.cos(angle) - (shortshoreLength - connectorWidth - 0.01) * Math.sin(angle) - (thickness + connectorThickness) * Math.cos(angle); // é€£æ¥æŸ±Zè»¸ä½ç½®
        const connectormidX_bk2_2 = connectormidX_bk2 - connectorWidth * Math.sin(angle); // é€£æ¥æŸ±Zè»¸é ‚æ¿ä½ç½®
        const connectmidXmid_bk_2 = (connectormidX_bk2 + connectormidX_bk2_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Zè»¸ä½ç½®
        const connectormidYmid_bk_2 = (connectormidY_bk2  + connectormidY_bk2_2) / 2; // ä¸­é–“é€£æ¥æŸ±ä¸­é»Zè»¸ä½ç½®

        const connectorMidPositions = [
          [connectmidXmid , connectormidYmid , 0],
          [connectmidXmid_2 , connectormidYmid_2 , 0],
          [connectmidXmid_bk , connectormidYmid_bk , 0],
          [connectmidXmid_bk_2 , connectormidYmid_bk_2 , 0],
  
        ];
        const connectorMidAxis = new THREE.Vector3(0, 0, 1); // é è¨­ z è»¸
        const connectorMidQuaternion = new THREE.Quaternion().setFromAxisAngle(connectorMidAxis, angle);
        // å»ºç«‹ä¸­é–“æ©‹æ¢é€£æ¥æŸ± Mesh
        connectorMidPositions.forEach(pos => {
          const connectorMid = new THREE.Mesh(connectorMidGeometry, connectorMidMaterial.clone());
          connectorMid.position.set(...pos);
          connectorMid.setRotationFromQuaternion(connectorMidQuaternion);
          scene.add(connectorMid);
        });

       
       
        // å»ºç«‹ä¸­é–“çš„å°è§’é€£æ¥æŸ±
        const connecotrMidslopeStart = new THREE.Vector3(connectormidX2_2 + connectorWidth * Math.sin(angle)*(1+0.75), connectormidY2_2 - connectorWidth * Math.cos(angle)*(1+0.75), offsetZ);
        const connecotrMidslopeEnd = new THREE.Vector3(connectormidX- connectorWidth * Math.sin(angle)*(1+0.75), connectormidY + connectorWidth * Math.cos(angle)*(1+0.75), -offsetZ);
        const connecotrMidslopeLength = Math.sqrt(Math.pow((spacing-0.1), 2) + Math.pow((connecotrMidslopeStart.x - connecotrMidslopeEnd.x), 2) + Math.pow((connecotrMidslopeStart.y - connecotrMidslopeEnd.y ), 2)); // è¨ˆç®—å°è§’é€£æ¥æŸ±çš„é•·åº¦
        // è¨ˆç®—å°è§’é€£æ¥æŸ±æ—‹è½‰
        const connecotrMidslopeAxis = new THREE.Vector3(0, 0, 1); 
        const connecotrMidslopeQuaternion = new THREE.Quaternion().setFromAxisAngle(connecotrMidslopeAxis,angle);
        // è¨ˆç®—å°è§’é€£æ¥æŸ±çš„æ–¹å‘
        const connecotrMidslopeDirection = new THREE.Vector3().subVectors(connecotrMidslopeStart, connecotrMidslopeEnd).normalize();
        const alignQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), connecotrMidslopeDirection);
        // å°‡å°è§’é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡æ–¹å‘å°é½Š
        // å…ˆæ–¹å‘å†é¸è½‰
        const finalQuaternion = alignQuaternion.multiply(connecotrMidslopeQuaternion); // å°‡å°è§’é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡æ–¹å‘å°é½Š

        const connectorMidslopeGeometry = new THREE.BoxGeometry(connectorThickness, connectorWidth, connecotrMidslopeLength );
        const connectorMidslopeMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000, // ç´…è‰²
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        const connecotrMidslopeMid = new THREE.Vector3().addVectors(connecotrMidslopeStart, connecotrMidslopeEnd).multiplyScalar(0.5);
        const connector = new THREE.Mesh(connectorMidslopeGeometry, connectorMidslopeMaterial);
        connector.position.copy(connecotrMidslopeMid);
        connector.setRotationFromQuaternion(finalQuaternion);
        scene.add(connector);



        // å»ºç«‹èƒŒé¢ä¸­é–“çš„å°è§’é€£æ¥æŸ±
        const connecotrMidslopeStart_bk = new THREE.Vector3(connectormidX_bk2_2 + connectorWidth * Math.sin(angle)*(1+0.75), connectormidY_bk2_2 - connectorWidth * Math.cos(angle)*(1+0.75), offsetZ);
        const connecotrMidslopeEnd_bk = new THREE.Vector3(connectormidX_bk - connectorWidth * Math.sin(angle)*(1+0.75), connectormidY_bk + connectorWidth * Math.cos(angle)*(1+0.75), -offsetZ);
        const connecotrMidslopeLength_bk = Math.sqrt(Math.pow((spacing-0.1), 2) + Math.pow((connecotrMidslopeStart_bk.x - connecotrMidslopeEnd_bk.x), 2) + Math.pow((connecotrMidslopeStart_bk.y - connecotrMidslopeEnd_bk.y ), 2)); // è¨ˆç®—å°è§’é€£æ¥æŸ±çš„é•·åº¦
        // è¨ˆç®—å°è§’é€£æ¥æŸ±æ—‹è½‰
        const connecotrMidslopeAxis_bk = new THREE.Vector3(0, 0, 1); 
        const connecotrMidslopeQuaternion_bk = new THREE.Quaternion().setFromAxisAngle(connecotrMidslopeAxis_bk,angle);
        // è¨ˆç®—å°è§’é€£æ¥æŸ±çš„æ–¹å‘
        const connecotrMidslopeDirection_bk = new THREE.Vector3().subVectors(connecotrMidslopeStart_bk, connecotrMidslopeEnd_bk).normalize();
        const alignQuaternion_bk = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), connecotrMidslopeDirection_bk);
        // å°‡å°è§’é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡æ–¹å‘å°é½Š
        // å…ˆæ–¹å‘å†é¸è½‰
        const finalQuaternion_bk = alignQuaternion_bk.multiply(connecotrMidslopeQuaternion_bk); 
        // å°‡å°è§’é€£æ¥æŸ±çš„æ—‹è½‰èˆ‡æ–¹å‘å°é½Š

        const connectorMidslopeGeometry_bk = new THREE.BoxGeometry(connectorThickness, connectorWidth, connecotrMidslopeLength_bk );
        const connectorMidslopeMaterial_bk = new THREE.MeshPhongMaterial({
          color: 0xff0000, // ç´…è‰²
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        const connecotrMidslopeMid_bk = new THREE.Vector3().addVectors(connecotrMidslopeStart_bk, connecotrMidslopeEnd_bk).multiplyScalar(0.5);
        const connector_bk = new THREE.Mesh(connectorMidslopeGeometry_bk, connectorMidslopeMaterial_bk);
        connector_bk.position.copy(connecotrMidslopeMid_bk);
        connector_bk.setRotationFromQuaternion(finalQuaternion_bk);
        scene.add(connector_bk);


        // å»ºç«‹å¤¾æ¿
        const plywoodGeometry = new THREE.BoxGeometry(0.15, 0.3, 0.02);
        const plywoodMaterial = new THREE.MeshPhongMaterial({
          color: 0xaaaaaa, // æ·ºç°
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        // Geometry x y z å°æ‡‰ å¯¬ã€é«˜ã€æ·±
        // èª¿ç”¨çš„ç”¨æ³•Geometry.parameters.width ã€.height ã€ .depth
        // å¤¾æ¿ä½ç½®è¨ˆç®—
        const plywoodXfront = shortPillarX - plywoodGeometry.parameters.width /2 ; // å‰å¤¾æ¿Xè»¸ä½ç½®
        const plywoodYfront = offsetY + bottomWidth +0.01; // å‰å¤¾æ¿Yè»¸ä½ç½®
        const plywoodXback = connectormidX_2 - connectorWidth/2 * Math.sin(angle) - plywoodGeometry.parameters.width/2 -0.01; // å¾Œå¤¾æ¿Xè»¸ä½ç½®
        const plywoodYback = offsetY + bottomWidth +0.01; // å¾Œå¤¾æ¿Yè»¸ä½ç½®
        const plywoodXfront_2 = shortPillarX_2 + (0.3 - topThickness * 2 ) / 2 * Math.sin(angle) + (0.15 - thickness + 0.03) / 2 * Math.cos(angle); // å‰å¤¾æ¿Xè»¸é ‚æ¿ä½ç½® 
        const plywoodYfront_2 = shortPillarY_2 - (0.3 - topThickness * 2 ) / 2 * Math.cos(angle) + (0.15 - thickness - 0.01) / 2 * Math.sin(angle); // å‰å¤¾æ¿Yè»¸é ‚æ¿ä½ç½®
        const plywoodXback_2 = PillarX_2 + (0.3 - topThickness * 2 ) / 2 * Math.sin(angle) - (0.15 - thickness + 0.01) / 2 * Math.cos(angle); // å¾Œå¤¾æ¿Xè»¸é ‚æ¿ä½ç½®
        const plywoodYback_2 = PillarY_2 - (0.3 - topThickness * 2 ) / 2 * Math.cos(angle) - (0.15 - thickness + 0.03) / 2 * Math.sin(angle); // å¾Œå¤¾æ¿Yè»¸é ‚æ¿ä½ç½®
        const plywoodPositionsUp = [
          [ plywoodXfront_2, plywoodYfront_2, + offsetZ - thickness / 2 - 0.02 / 2], // å‰å·¦ä¸Š
          [ plywoodXfront_2, plywoodYfront_2, -offsetZ + thickness / 2 + 0.02 / 2], // å¾Œå·¦ä¸Š
          [ plywoodXback_2, plywoodYback_2, + offsetZ + thickness / 2 + 0.02 / 2], // å‰å³ä¸Š
          [ plywoodXback_2, plywoodYback_2, -offsetZ - thickness / 2 - 0.02 / 2] // å¾Œå³ä¸Š

        ];
        const plywoodAxis = new THREE.Vector3(0, 0, 1);
        const plywoodQuaternion = new THREE.Quaternion().setFromAxisAngle(plywoodAxis, angle);
        // å»ºç«‹ä¸­é–“æ©‹æ¢é€£æ¥æŸ± Mesh
        plywoodPositionsUp.forEach(pos => {
          const plywood = new THREE.Mesh(plywoodGeometry, plywoodMaterial.clone());
          plywood.position.set(...pos);
          plywood.setRotationFromQuaternion(plywoodQuaternion);
          scene.add(plywood);
        });

        const plywoodPositionsDown = [
          [ plywoodXfront, plywoodYfront, offsetZ + thickness / 2 + 0.02 / 2], // å‰å·¦ä¸‹
          [ plywoodXfront, plywoodYfront, -offsetZ - thickness / 2 - 0.02 / 2], // å¾Œå·¦ä¸‹
          [ plywoodXback, plywoodYback, offsetZ - thickness / 2 - 0.02 / 2], // å‰å³ä¸‹
          [ plywoodXback, plywoodYback, -offsetZ + thickness / 2 + 0.02 / 2], // å¾Œå³ä¸‹
        ];
        plywoodPositionsDown.forEach(pos => {
          const plywood = new THREE.Mesh(plywoodGeometry, plywoodMaterial.clone());
          plywood.position.set(...pos);
          scene.add(plywood);
        });



        //ä¹‹å¾Œå¯ä»¥åˆªé™¤
        // å»ºç«‹ XYZ è»¸å‘è¼”åŠ©ç·šï¼ˆé•·åº¦å–®ä½ = å…¬å°ºï¼Œå¯èª¿æ•´ï¼‰
        //x,y,z:ç´…,ç¶ ,è—
        /*
        const axesHelper = new THREE.AxesHelper(1);  // é•·åº¦ 1 å…¬å°º
        scene.add(axesHelper);
        */
        // ä»¥ä¸‹ç‚ºç’°å¢ƒè¨­ç½®
        // ç›¸æ©Ÿä½ç½®
        const maxSize = Math.max(spacing, height, thickness);
        camera.position.set(maxSize * 2, maxSize * 2, maxSize * 2);
        camera.lookAt(0, 0, 0);

        // æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;

        // æ¸²æŸ“
        function animate() {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();


      } else {
        result.innerHTML = `<div class="result">ç¼ºå°‘å¿…è¦è³‡æ–™ï¼Œç„¡æ³•è¨ˆç®—ï¼</div>`;
      }
    }

  </script>



</body>
</html>
